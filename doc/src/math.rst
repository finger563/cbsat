Math
====

This page describes the mathematical formalization
behind the network analysis techniques used by this
tool.  These techniques are based on Network Calculus
and have been published in these papers.

Network Calculus Background
---------------------------

Network Calculus, on the other hand, focuses on abstracting the network traffic and the computing nodes as arrival curves and traffic shapers. The arrival curves and service curves model the amount of data generated or serviced in a given window of time and are bounded by maximum and minimum arrival and service curves.  These bounds provide the requisite information needed to make design-time guarantees about *worst-case* application performance on the network, given that both the application traffic profile and the system's network performance are deterministic. These deterministic constraints can be relaxed so that the arrival and service curves can be probabilistic, causing the bounds on the performance to be probabilistic as well.  Because Network Calculus deals with either deterministic worst-case application performance on a static network or stochastic application performance on a dynamic network, system designers and application designers under-utilize the network resources of systems which require strict design-time guarantees about application performance.  

Formalism for Better Precision Network Analysis
-----------------------------------------------

To model the network capability of the system and the application traffic patterns, we have developed a network modeling paradigm similar to Network Calculus' traffic arrival curves and traffic shaper service curves.  

Similarly to Network Calculus' arrival curves and service curves, our network profiles model how the network performance or application traffic generation changes with respect to time.  Whereas Network Calculus' modeling transforms application data profiles and network service profiles into min and max curves for data received vs. size of time-window, our models take a simpler, deterministic approach which models exactly the data generated by the application and the data which could be sent through the network, allowing our performance metrics to be more precise.  Specifically, the bandwidth that the network provides on a given communication link is specified as a time series of scalar bandwidth values. Here, bandwidth is defined as data rate, i.e. bits per second, over some averaging interval.  This bandwidth profile can then be time-integrated to determine the maximum amount of data throughput the network link could provide over a given time.  The bandwidth profile for the application traffic similarly can be time-integrated to determine the amount of data that the application attempts to send on the network link as a function of time.

Having time-integrated the bandwidth profiles to obtain data vs. time profiles that the application requires and that the system provides, we can use convolution (:math:`\otimes`) on these two profiles to obtain the transmitted link data profile as a function of discrete time. The convolution we define on these profiles borrows concepts from the min-plus calculus used in Network Calculus, but does not use a sliding-window and instead takes the transformed minimum of the profiles. For a given application data generation profile, :math:`r[t]`, and a given system link capacity profile :math:`p[t]`, where :math:`t\in\mathbb{N}`, the link transmitted data profile :math:`l[t]` is given by the convolution Equation~\ref{eq:convolution}. The difference :math:`(p[t-1] - l[t-1])` represents the difference between the amount of data that has been transmitted on the link :math:`(l[t-1])` and the data that the link could have transmitted at full utilization :math:`(p[t-1])`. As demonstrated by the convolution equation, :math:`\forall t : l[t] \le r[t]`, which is the relation that, without lower-layer reliable transport, the link cannot transmit more application data for the application than the application requests as there will be packetization and communication header overhead as well. 

.. math::
   y=l[t] &= (r \otimes p)[t] \\
   &= min( r[t] , p[t] - (p[t-1] - l[t-1]) )

   &\text{buffer}= sup\{r[t] - l[t] : t \in \mathbb{N}\}\\
   &\text{delay} = sup\{l^{-1}[y]-r^{-1}[y] : y \in \mathbb{N}\}

.. figure:: /images/math/convolution.png
   :align: center


