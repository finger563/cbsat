

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Design Time Results &mdash; Research Progress Report  documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="./_static/custom.css" type="text/css" />
  

  
    <link rel="top" title="Research Progress Report  documentation" href="index.html"/>
        <link rel="up" title="Precise Network Performance Prediction : Results" href="results.html"/>
        <link rel="next" title="Run Time Results" href="run-time.html"/>
        <link rel="prev" title="Precise Network Performance Prediction : Results" href="results.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        

        
          <a href="index.html" class="icon icon-home"> Research Progress Report
        

        
        </a>

        
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

        
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
          
          
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="getting-started.html">Getting Started</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="theory-results.html">Background, Theory, and Results</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="background.html">Background: Network Performance Analysis</a><ul>
<li class="toctree-l3"><a class="reference internal" href="background.html#min-plus-calculus">Min-Plus Calculus</a></li>
<li class="toctree-l3"><a class="reference internal" href="background.html#network-calculus">Network Calculus</a></li>
<li class="toctree-l3"><a class="reference internal" href="background.html#real-time-calculus">Real Time Calculus</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="math.html">Precise Network Performance Prediction : Theory</a><ul>
<li class="toctree-l3"><a class="reference internal" href="math.html#mathematical-formalism">Mathematical Formalism</a></li>
<li class="toctree-l3"><a class="reference internal" href="math.html#assumptions-involved">Assumptions Involved</a></li>
<li class="toctree-l3"><a class="reference internal" href="math.html#factors-impacting-analysis">Factors Impacting Analysis</a></li>
</ul>
</li>
<li class="toctree-l2 current"><a class="reference internal" href="results.html">Precise Network Performance Prediction : Results</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="">Design Time Results</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#periodic-system-analysis">Periodic System Analysis</a></li>
<li class="toctree-l4"><a class="reference internal" href="#comparison-with-nc-rtc">Comparison with NC/RTC</a></li>
<li class="toctree-l4"><a class="reference internal" href="#analysis-of-tdma-scheduling">Analysis of TDMA Scheduling</a></li>
<li class="toctree-l4"><a class="reference internal" href="#compositional-analysis">Compositional Analysis</a></li>
<li class="toctree-l4"><a class="reference internal" href="#delay-analysis">Delay Analysis</a></li>
<li class="toctree-l4"><a class="reference internal" href="#routing-analysis">Routing Analysis</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="run-time.html">Run Time Results</a><ul>
<li class="toctree-l4"><a class="reference internal" href="run-time.html#middleware-integrated-measurement-detection-and-enforcement">Middleware-integrated Measurement, Detection, and Enforcement</a></li>
<li class="toctree-l4"><a class="reference internal" href="run-time.html#distributed-denial-of-service-ddos-detection">Distributed Denial of Service (DDoS) Detection</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="users.html">Using the Code</a><ul>
<li class="toctree-l2"><a class="reference internal" href="users.html#the-analysis-tool">The Analysis Tool</a><ul>
<li class="toctree-l3"><a class="reference internal" href="users.html#installation">Installation</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="users.html#the-middleware">The Middleware</a><ul>
<li class="toctree-l3"><a class="reference internal" href="users.html#compilation">Compilation</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="developers.html">The Inner Workings</a><ul>
<li class="toctree-l2"><a class="reference internal" href="analysis-api.html">Analysis API</a><ul>
<li class="toctree-l3"><a class="reference internal" href="python-api/analysis/analysis.html">Analysis</a></li>
<li class="toctree-l3"><a class="reference internal" href="python-api/analysis/network-profile.html">Network Profile</a></li>
<li class="toctree-l3"><a class="reference internal" href="python-api/analysis/network-config.html">Network Config</a></li>
<li class="toctree-l3"><a class="reference internal" href="python-api/analysis/plotting.html">Plotting</a></li>
<li class="toctree-l3"><a class="reference internal" href="python-api/analysis/utils.html">Utils</a></li>
<li class="toctree-l3"><a class="reference internal" href="python-api/analysis/generate-tdma.html">Generate TDMA</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="middleware-api.html">Middleware API</a><ul>
<li class="toctree-l3"><a class="reference internal" href="python-api/middleware/network-profile.html">Network Profile</a></li>
<li class="toctree-l3"><a class="reference internal" href="python-api/middleware/network-buffer.html">Network Buffer</a></li>
<li class="toctree-l3"><a class="reference internal" href="python-api/middleware/network-middleware.html">Network Middleware</a></li>
<li class="toctree-l3"><a class="reference internal" href="python-api/middleware/message.html">Message</a></li>
<li class="toctree-l3"><a class="reference internal" href="python-api/middleware/client.html">Client</a></li>
<li class="toctree-l3"><a class="reference internal" href="python-api/middleware/server.html">Server</a></li>
<li class="toctree-l3"><a class="reference internal" href="python-api/middleware/connection-subsys.html">Connection Subsys</a></li>
<li class="toctree-l3"><a class="reference internal" href="python-api/middleware/csv-iterator.html">CSV Iterator</a></li>
<li class="toctree-l3"><a class="reference internal" href="python-api/middleware/tc-wrapper.html">TC Wrapper</a></li>
</ul>
</li>
</ul>
</li>
</ul>

          
        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">Research Progress Report</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
          <li><a href="theory-results.html">Background, Theory, and Results</a> &raquo;</li>
      
          <li><a href="results.html">Precise Network Performance Prediction : Results</a> &raquo;</li>
      
    <li>Design Time Results</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/design-time.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document">
            
  <div class="section" id="design-time-results">
<span id="design-time"></span><h1>Design Time Results<a class="headerlink" href="#design-time-results" title="Permalink to this headline">¶</a></h1>
<p>These results provide a methodology and a means for application
developers and system integrators to determine conservative, precise,
tightly bounded performance metrics for distributed networked
applications and systems at design time.  The contributions of this
work are broken into sections by topic:</p>
<ul class="simple">
<li><a class="reference internal" href="#periodic-system-analysis"><span>Periodic System Analysis</span></a></li>
<li><a class="reference internal" href="#periodic-analysis-proof"><span>Proving the Minimum Analysis for System Stability</span></a></li>
<li><a class="reference internal" href="#nc-comparison"><span>Comparison with NC/RTC</span></a></li>
<li><a class="reference internal" href="#tdma-analysis"><span>Analysis of TDMA Scheduling</span></a></li>
<li><a class="reference internal" href="#compositional-analysis"><span>Compositional Analysis</span></a></li>
<li><a class="reference internal" href="#delay-analysis"><span>Delay Analysis</span></a></li>
<li><a class="reference internal" href="#routing-analysis"><span>Routing Analysis</span></a></li>
</ul>
<div class="section" id="periodic-system-analysis">
<span id="id1"></span><h2>Periodic System Analysis<a class="headerlink" href="#periodic-system-analysis" title="Permalink to this headline">¶</a></h2>
<p>One subset of systems which we would like to analyze are periodic
systems, since many systems in the real world exhibit some form of
periodicity, e.g. satellites in orbit, traffic congestion patterns,
power draw patterns.  We define systems to be periodic if the data
production rate (or consumption rate) of the system is a periodic
function of time.  The time-integral of these periodic data
consumption/production rates is the cumulative data
production/consumption of the system.  These cumulative functions are
called <em>repeating</em>.</p>
<p>Given that the required data profile and system data service profile
are <em>repeating</em>, we must determine the periodicity of the output
profile.  If we can show that the output profile similarly repeats,
then we can show that the system has no unbounded buffer growth.
First, let us look at the profile behavior over the course of its
first two periods of activity.</p>
<p>We will examine two systems, <em>system (1)</em> and <em>system (2)</em>.  Firstly,
examine <em>(1)</em>, shown below (note: you can click on the images to open
them in a larger format):</p>
<table border="1" class="docutils">
<colgroup>
<col width="49%" />
<col width="51%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">System <em>(1)</em> Bandwidth for 1 Period</th>
<th class="head">System <em>(1)</em> Data for 1 Period</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><a class="first last reference internal image-reference" href="_images/1-period-system-bw.png"><img alt="_images/1-period-system-bw.png" src="_images/1-period-system-bw.png" style="height: 200px;" /></a>
</td>
<td><a class="first last reference internal image-reference" href="_images/1-period-system-data.png"><img alt="_images/1-period-system-data.png" src="_images/1-period-system-data.png" style="height: 200px;" /></a>
</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="49%" />
<col width="51%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">System <em>(1)</em> Bandwidth for 2 Periods</th>
<th class="head">System <em>(1)</em> Data for 2 Periods</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><a class="first last reference internal image-reference" href="_images/2-period-system-bw.png"><img alt="_images/2-period-system-bw.png" src="_images/2-period-system-bw.png" style="height: 200px;" /></a>
</td>
<td><a class="first last reference internal image-reference" href="_images/2-period-system-data.png"><img alt="_images/2-period-system-data.png" src="_images/2-period-system-data.png" style="height: 200px;" /></a>
</td>
</tr>
</tbody>
</table>
<p>We notice that for this example system, the second period output
profile is not an exact copy of the first (most easily seen by
examining the bandwidth plots), and yet the required buffer size is
still the same as it was when analyzing the system over one period.
Furthermore, by running the analysis over even larger number of
periods, we can determine (not plotted here for space and
readability), that the predicted buffer size does not change no matter
how many periods we analyze for this system.</p>
<p>Let us look at a system where this is not the case before we begin the
analysis of such system characteristics.</p>
<table border="1" class="docutils">
<colgroup>
<col width="49%" />
<col width="51%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">System <em>(2)</em> Bandwidth for 1 Period</th>
<th class="head">System <em>(2)</em> Data for 1 Period</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><a class="first last reference internal image-reference" href="_images/1-period-unstable-bw.png"><img alt="_images/1-period-unstable-bw.png" src="_images/1-period-unstable-bw.png" style="height: 200px;" /></a>
</td>
<td><a class="first last reference internal image-reference" href="_images/1-period-unstable-data.png"><img alt="_images/1-period-unstable-data.png" src="_images/1-period-unstable-data.png" style="height: 200px;" /></a>
</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="49%" />
<col width="51%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">System <em>(2)</em> Bandwidth for 2 Periods</th>
<th class="head">System <em>(2)</em> Data for 2 Periods</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><a class="first last reference internal image-reference" href="_images/2-period-unstable-bw.png"><img alt="_images/2-period-unstable-bw.png" src="_images/2-period-unstable-bw.png" style="height: 200px;" /></a>
</td>
<td><a class="first last reference internal image-reference" href="_images/2-period-unstable-data.png"><img alt="_images/2-period-unstable-data.png" src="_images/2-period-unstable-data.png" style="height: 200px;" /></a>
</td>
</tr>
</tbody>
</table>
<p>Notice in system <em>(2)</em>, the first period analysis predicted the same
buffer size and delay as system <em>(1)</em>, but when analyzing two periods
the predicted buffer size changed.  Clearly the behavior of the system
is changing between these two periods.  If we continue to analyze more
periods of system <em>(2)</em>, as we did with system <em>(1)</em>, we&#8217;ll find the
unfortunate conclusion that the predicted buffer size increases with
every period we add to the analysis.</p>
<p>We have discovered a system level property that can be calculated from
these profiles, but we must determine what it means and how it can be
used.  First, we see that in system <em>(1)</em>, the predicted required
buffer size does not change regarless of the number of periods over
which we analyze the system.  Second, we see that for system <em>(2)</em>,
the predicted required buffer size changes depending on how many
periods of activity we choose for our analysis window.  Third, we see
that the second period of system <em>(2)</em> contains the larger of the two
predicted buffer sizes.  These observations (with our understanding of
deterministic periodic systems) lead us to the conclusion: system
<em>(2)</em> can no longer be classified as periodic, since its behavior is
not consistent between its periods.  Furthermore, because the required
buffer size predicted for system system <em>(2)</em> continually increases,
we can determine that the system is in fact <em>unstable</em> due to
unbounded buffer growth.</p>
<div class="section" id="proving-the-minimum-analysis-for-system-stability">
<span id="periodic-analysis-proof"></span><h3>Proving the Minimum Analysis for System Stability<a class="headerlink" href="#proving-the-minimum-analysis-for-system-stability" title="Permalink to this headline">¶</a></h3>
<p>Let us now formally prove the assertion about system periodicity and
stability which has been stated above.  We will show that our analysis
results provide quantitative measures about the behavior of the system
and we will determine for how long we must analyze a system to glean
such behaviors.</p>
<p>Typically, periodicity is defined for functions as the equality:</p>
<div class="math">
<p><img src="_images/math/c334144f9896123b590c4cfccaa70ca012c95807.png" alt="x(t) = x(t + k * T), \forall k \in \mathbb{N} &gt; 0"/></p>
</div><p>but for our type of system analysis this cannot hold since we deal
with cumulative functions (of data vs. time).  Instead we must define
a these functions to be <strong>repeating</strong>, where a function is repeating
<em>iff</em>:</p>
<div class="math">
<p><img src="_images/math/30e4f8159751a8c913decd16c7a8703a205ebd79.png" alt="x(0) &amp;= 0 \text{  and}\\
x(t + k * T) &amp;= x(t) + k * x(T), \forall k \in \mathbb{N} &gt; 0"/></p>
</div><p>Clearly, a repeating function <img class="math" src="_images/math/188c175aac0a8a9c22499336711b5d7256407254.png" alt="x"/> is <strong>periodic</strong> <em>iff</em>
<img class="math" src="_images/math/20c77058fe03716b694fb60e36e18d8d2170c018.png" alt="x(T)=0"/>.  Note that repeating functions like the cumulative
data vs. time profiles we deal with, are the result of <strong>integrating</strong>
<em>periodic</em> functions, like the periodic bandwidth vs. time profiles we
use to describe application network traffic and system network
capacity.  All periodic functions, when integrated, produce repeating
functions and similarly, all repeating functions, when differentiated,
procduce periodic functions.</p>
<p>Now we will consider a deterministic, <em>repeating</em> queuing system
providing a data service function <img class="math" src="_images/math/11a85f3c69ae6702cb1d99d3de451913b8f84c04.png" alt="S"/> to input data function
<img class="math" src="_images/math/5d9e7b2aec3287330051a115f2ea3cdc8c7a6587.png" alt="I"/> to produce output data function <img class="math" src="_images/math/f3f716e1c56d5ebdca97bb1546662b9e96f5be07.png" alt="O"/>, where these
functions are <em>cumulative data versus time</em>.  At any time <img class="math" src="_images/math/ef9270877405055756d345facd044e4ab297f858.png" alt="t"/>,
the amount of data in the system&#8217;s buffer is given by <img class="math" src="_images/math/182fedb62e8623cd880abf38d211d0455fa2e477.png" alt="B_t"/>.
After servicing the input, the system has a remaining capacity
function <img class="math" src="_images/math/9d86170e7de539c0ff999de09621ee0c7b6c8ed0.png" alt="R"/>.</p>
<ul class="simple">
<li><img class="math" src="_images/math/a08ad3515eac0feebd61d7a1b6eaf157eedbdd3e.png" alt="S[t]"/> : the service function of the system, cumulative data
service capacity versus time</li>
<li><img class="math" src="_images/math/6d5f8ae3ceb47a2a475bb2f02fc8107d6ffb9b06.png" alt="I[t]"/> : the input data to the system, cumulative data versus
time</li>
<li><img class="math" src="_images/math/a4b883e2dcb9cf31b5a935b8539949ef4333dfc8.png" alt="O[t]"/> : the output data from the system, cumulative data
versus time</li>
<li><img class="math" src="_images/math/01cd005a7eb681a16f7d214ea489cee0570eca8f.png" alt="B[t]"/> : the amount of data in the system&#8217;s buffer at time
<img class="math" src="_images/math/ef9270877405055756d345facd044e4ab297f858.png" alt="t"/>, i.e. <img class="math" src="_images/math/2e3d35b2dc6e8c76e4412baaa21a1b190aed4d37.png" alt="I[t]-O[t]"/></li>
<li><img class="math" src="_images/math/2296df10353d0d24932ae9239bb1c004522bd7d2.png" alt="R[t]"/> : the remaining service capacity of the system after
servicing <img class="math" src="_images/math/5d9e7b2aec3287330051a115f2ea3cdc8c7a6587.png" alt="I"/>, i.e. <img class="math" src="_images/math/6e4faafd2b95bb8f49c163b2d0436418269ab2d7.png" alt="S[t] - O[t]"/></li>
</ul>
<p>Because <img class="math" src="_images/math/11a85f3c69ae6702cb1d99d3de451913b8f84c04.png" alt="S"/> and <img class="math" src="_images/math/5d9e7b2aec3287330051a115f2ea3cdc8c7a6587.png" alt="I"/> are deterministic and repeating, they
increase deterministically from period to period, i.e. given the
period <img class="math" src="_images/math/5ff95e0eeb56451cbcfe611d1c422c9381195596.png" alt="T_I"/> of <img class="math" src="_images/math/5d9e7b2aec3287330051a115f2ea3cdc8c7a6587.png" alt="I"/>,</p>
<div class="math">
<p><img src="_images/math/f6f17ef56dfd78aded3eb9a70efc05b9e251982e.png" alt="\forall t, \forall n \in \mathbb{N} &gt; 0 : I[t + n*T_I] =
I[t] + n*I[T_I]"/></p>
</div><p>Similarly, given the period <img class="math" src="_images/math/c1060ce177cee9b3af63aa8e847dbe201c1afab0.png" alt="T_S"/> of <img class="math" src="_images/math/11a85f3c69ae6702cb1d99d3de451913b8f84c04.png" alt="S"/>,</p>
<div class="math">
<p><img src="_images/math/e5b4dfc1d0a3e7ab61648bf6220ad3d01caee114.png" alt="\forall t, \forall n \in \mathbb{N} &gt; 0 : S[t + n*T_S] =
S[t] + n*S[T_S]"/></p>
</div><p>We can determine the hyperperiod of the system as the <img class="math" src="_images/math/e83965b2f16217c11c9dcb2f0a671f40da396ed3.png" alt="lcm"/> of
input function period and the service function period, <img class="math" src="_images/math/3856e38d70416a9b3dee493b4190ed04456c6428.png" alt="T_p =
lcm(T_S,T_I)"/>.</p>
<p>At the start of the system, <img class="math" src="_images/math/4e2677b4edfbb85a135b7807d780a44ffa83f052.png" alt="t=0"/>, the system&#8217;s buffer is empty,
i.e.  <img class="math" src="_images/math/f6a3588d85e5c4783a1151a85bdb615bb4d66db1.png" alt="B[0] = 0"/>.  Therefore, the amount of data in the buffer
at the end of the first period, <img class="math" src="_images/math/99a8de8b225ffd7a8236c5d0894b31d1ce616cc4.png" alt="t=T_p"/>, is the amount of data
that entered the system on input function <img class="math" src="_images/math/5d9e7b2aec3287330051a115f2ea3cdc8c7a6587.png" alt="I"/> but was not able
to be serviced by <img class="math" src="_images/math/11a85f3c69ae6702cb1d99d3de451913b8f84c04.png" alt="S"/>.  At the start of the next period, this
data will exist in the buffer.  Data in the buffer at the start of the
period can be compared to the system&#8217;s remaining capacity <img class="math" src="_images/math/9d86170e7de539c0ff999de09621ee0c7b6c8ed0.png" alt="R"/>,
since the remaining capacity of the system indicates how much extra
data it can transmit in that period.  Consider the scenario that the
system&#8217;s remaining capacity <img class="math" src="_images/math/9d86170e7de539c0ff999de09621ee0c7b6c8ed0.png" alt="R"/> is less than the size of the
buffer, i.e. <img class="math" src="_images/math/d196db590a966706d982ef4e085bf610163f423e.png" alt="R[T_p] &lt; B[T_p]"/>.  In this scenario,
<img class="math" src="_images/math/d122eaebcd3be7a2931e55b4f8a488d7fd88e9c2.png" alt="B[2*T_p] &gt; B[T_p]"/>, i.e. there will be more data in the buffer
at the end of the second period than there was at the end of the first
period.  Since the system is deterministic, for any two successive
periods, <img class="math" src="_images/math/b9a9df387042bbb0961875f39567147b9326c3e0.png" alt="n*T_p"/> and <img class="math" src="_images/math/819cd3c4776e788abaa849b87e2071c589d13d0f.png" alt="(n+1)*T_p"/>, <img class="math" src="_images/math/be3783ed63b7ea54b972111d1dec43c2dea7d6dc.png" alt="B[n*T_p] &gt;
B[(n+1)*T_p]"/>, which extends to:</p>
<div class="math">
<p><img src="_images/math/b32dffeddd6858728ce6aa1959a915155e7a9f39.png" alt="B[m*T_p] &gt; B[n*T_p], \forall m&gt;n&gt;0"/></p>
</div><p>implying that:</p>
<div class="math">
<p><img src="_images/math/b50abfbe06ba9876952e1d0cca84f9d8c99b41a8.png" alt="B[t] &lt; B[t + k*T_p], \forall k \in \mathbb{N} &gt; 0"/></p>
</div><p>meaning that the amount of data in the buffer versus time is <em>not
periodic</em>, therefore the amount of data in the system&#8217;s buffer
increases every period, i.e. the system has <em>unbounded buffer growth</em>.</p>
<p>If however, there is enough remaining capacity in the system to
service the data in the buffer, i.e. <img class="math" src="_images/math/f14219b37c6f7adadce486123a40ecf1f8514a45.png" alt="R[T_p] &gt;= B[T_p]"/>, then
<img class="math" src="_images/math/33d4f4dd02841f21b6856ee7772cc8d0f77c4bf3.png" alt="B[2*T_p] = B[T_p]"/>.  This relation means that if the remaining
capacity of the system that exists after all the period&#8217;s required
traffic has been serviced is equal to or larger than the size of the
buffer at the end of the period, then in the next period the system
will be able to service fully both the data in the buffer and the
period&#8217;s required traffic.  Since both the period&#8217;s traffic and the
buffer&#8217;s data will have been serviced in that period, the amount of
data in the buffer at the end of the period will be the same as the
amount of data that was in the buffer at the start of the
period. Similarly to above, since the system is deterministic, for any
two successive periods, <img class="math" src="_images/math/b9a9df387042bbb0961875f39567147b9326c3e0.png" alt="n*T_p"/> and <img class="math" src="_images/math/819cd3c4776e788abaa849b87e2071c589d13d0f.png" alt="(n+1)*T_p"/>,
<img class="math" src="_images/math/875277b8532466efb8412008d89be2dc4e8d5ee9.png" alt="B[(n+1)*T_p] = B[n*T_p]"/>.  This extends to:</p>
<div class="math">
<p><img src="_images/math/feaedd13a5444527e22d3532712f4e23dbc59f03.png" alt="B[m*T_p] = B[n*T_p], \forall m,n &gt; 0"/></p>
</div><p>which implies that:</p>
<div class="math">
<p><img src="_images/math/171f87f18e3be14ff2d7162761ac2f0f92e887e3.png" alt="B[t] = B[t + k*T_p], \forall k \in \mathbb{N} &gt; 0"/></p>
</div><p>meaning that the amount of data in the buffer versus time is a
<em>periodic function</em>, therefore the buffer size does not grow between
periods, and the system has a <em>finite buffer</em>.</p>
<p>If we are only concerned with buffer growth, we do not need to
calculate <img class="math" src="_images/math/9d86170e7de539c0ff999de09621ee0c7b6c8ed0.png" alt="R"/>, and can instead infer buffer growth by comparing
the values of the buffer at any two period-offset times during the
steady-state operation of the system (<img class="math" src="_images/math/7bca1764693474a28844c96d8310bca28a0509b8.png" alt="t &gt;= T_p"/>).  This means
that the system buffer growth check can resolve to <img class="math" src="_images/math/22f50a751ef795d2b5dd655238463e698c18a4c9.png" alt="B[2*T_p] ==
B[T_p]"/>.  This comparison abides by the conditions above, with
<img class="math" src="_images/math/70040fec2de75cc96fc8cc94208dbfc28684cc85.png" alt="m=2"/> and <img class="math" src="_images/math/163a19eac5182aaabe8bd9cc931dfa15e75a71dc.png" alt="n=1"/>.</p>
</div>
</div>
<div class="section" id="comparison-with-nc-rtc">
<span id="nc-comparison"></span><h2>Comparison with NC/RTC<a class="headerlink" href="#comparison-with-nc-rtc" title="Permalink to this headline">¶</a></h2>
<p>To show how our analysis techniques compare to other available
methods, we developed our tools to allow us to analyze the input
system using Network Calculus/Real-Time Calculus techniques as well as
our own.  Using these capabilities, we can directly compare the
analysis results to each other, and then finally compare both results
to the measurements from the actual system.</p>
<table border="1" class="docutils">
<colgroup>
<col width="49%" />
<col width="51%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">System Data Rate vs. Time</th>
<th class="head">System Data Analyzed with <img class="math" src="_images/math/25e201674a37202d448849e78eb163897d9373f6.png" alt="PNP^2"/></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><a class="first last reference internal image-reference" href="_images/maren_namek_bw.png"><img alt="_images/maren_namek_bw.png" src="_images/maren_namek_bw.png" style="height: 200px;" /></a>
</td>
<td><a class="first last reference internal image-reference" href="_images/maren_namek_data.png"><img alt="_images/maren_namek_data.png" src="_images/maren_namek_data.png" style="height: 200px;" /></a>
</td>
</tr>
</tbody>
</table>
<div class="figure align-center" id="id5">
<span id="fig-zoom"></span><a class="reference internal image-reference" href="_images/maren_namek_data_zoom.png"><img alt="_images/maren_namek_data_zoom.png" src="_images/maren_namek_data_zoom.png" style="width: 400px; height: 400px;" /></a>
<p class="caption"><span class="caption-text">Figure 1: Zoomed-in version of <img class="math" src="_images/math/25e201674a37202d448849e78eb163897d9373f6.png" alt="PNP^2"/> analysis.</span></p>
</div>
<div class="figure align-center" id="id6">
<span id="fig-data-nc"></span><a class="reference internal image-reference" href="_images/nc_namek_data.png"><img alt="_images/nc_namek_data.png" src="_images/nc_namek_data.png" style="width: 400px; height: 400px;" /></a>
<p class="caption"><span class="caption-text">Figure 2: Network-Calculus based analysis of the system.</span></p>
</div>
<p>The table above shows the data rate versus time profile describing the
example system, side-by-side with the time-integrated and analyzed
data versus time profile.  <a class="pageref" href="#fig-zoom">Figure  1</a> shows a zoomed in
portion of the second plot, focusing on the area with the maximum
delay and buffer as analyzed by <img class="math" src="_images/math/25e201674a37202d448849e78eb163897d9373f6.png" alt="PNP^2"/>.  <a class="pageref" href="#fig-data-nc">Figure  2</a> shows the same system analyzed using Network Calculus.</p>
<p>The major drawback for Network Calculus that our work aims to solve is
the disconnect from the real system that stems from using an approach
based on time-window analysis.  Such an approach leads to dramatically
under-approximating the capacity of the network while simultaneously
over-approximating the utilization of the network, since a known drop
in network performance which is expected and handled by the
application cannot be accurately modeled.  In our case, the system is
using a system profile which can service data during the period from
<img class="math" src="_images/math/76ef67173b0843b70edb0503ab614cc3d716ddf2.png" alt="0\le t\le 7"/> seconds with a period of 10 seconds.  The
application is designed around this constraint and only produces data
during that interval.  Because our technique directly compares when
the application produces data to when the system can service the data,
we are able to derive more precise performance prediction metrics than
Network Calculus, which compares the 3 seconds of system downtime to
the 3 seconds of maximum application data production.</p>
<p>We developed software which produces data according to a supplied
input profile and configured the system&#8217;s network to provide the
bandwidth profile described in the system configuration profile.
Using this experimental infrastructure, we were able to measure the
transmitted traffic profile, the received traffic profile, the latency
experienced by the data, and the transmitter&#8217;s buffer requirements.
The results are displayed in the table below:</p>
<table border="1" class="docutils">
<colgroup>
<col width="32%" />
<col width="21%" />
<col width="47%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">&nbsp;</th>
<th class="head">Predicted</th>
<th class="head">Measured (<img class="math" src="_images/math/4b4dedc5cdec56161ae4dac2a0baf86f1c72b094.png" alt="\mu,\sigma"/>)</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Buffer Delay (s)</td>
<td>0.0625</td>
<td>(0.06003 , 0.00029)</td>
</tr>
<tr class="row-odd"><td>Time of Delay (s)</td>
<td>3.0</td>
<td>(2.90547 , 0.00025)</td>
</tr>
<tr class="row-even"><td>Buffer Size (bytes)</td>
<td>8000</td>
<td>(7722.59 , 36.94)</td>
</tr>
</tbody>
</table>
<p>Taking the results from our published work, where our methods
predicted a buffer size of 64000 bits / 8000 bytes, we show that
Network Calculus predicts a required buffer size of 3155000 bits. This
drastic difference comes from the mis-match between down-time and max
data production mentioned above.</p>
</div>
<div class="section" id="analysis-of-tdma-scheduling">
<span id="tdma-analysis"></span><h2>Analysis of TDMA Scheduling<a class="headerlink" href="#analysis-of-tdma-scheduling" title="Permalink to this headline">¶</a></h2>
<p>Medium channel access (MAC) protocols are used in networking systems
to govern the communication between computing nodes which share a
network communications medium.  They are designed to allow reliable
communication between the nodes, while maintaining certain goals, such
as minimizing network collisions, maximizing bandwidth, or maximizing
the number of nodes the network can handle.  Such protocols include
Time Division Multiple Access (TDMA), which tries to minimize the
number of packet collisions; Frequency Division Multiple Access
(FDMA), which tries to maximize the bandwidth available to each
transmitter; and Code Division Multiple Access (CDMA) which tries to
maximize the number of nodes that the network can handle.  We will not
discuss CDMA in the scope of this work.</p>
<p>In FDMA, each node of the network is assigned a different transmission
frequency from a prescribed frequency band allocated for system
communications.  Since each node transmits on its own frequency,
collisions between nodes transmitting simultaneously are reduced.
Communications paradigms of this type, i.e. shared medium with
collision-free simultaneous transmission between nodes, can be modeled
easily by our <img class="math" src="_images/math/25e201674a37202d448849e78eb163897d9373f6.png" alt="PNP^2"/> modeling paradigm described above, since
the network resource model for each node can be developed without
taking into account the transmissions of other nodes.</p>
<p>In TDMA, each node on the network is assigned one or more time-slots
per communications period in which only that node is allowed to
transmit.  By governing these timeslots and having each node agree
upon the slot allocation and communications period, the protocol
ensures that at a given time, only a single node will be transmitting
data, minimizing the number of collisions due to multiple simultaneous
transmitters.  In such a medium access protocol, transmissions of each
node affect other nodes&#8217; transmission capability.  Because these
transmissions are scheduled by TDMA, they can be explicitly integrated
into the system network resource model.</p>
<p>TDMA transmission scheduling has an impact on the timing
characteristics of the applications&#8217; network communications.  Because
applications&#8217; network data production is decoupled from their node&#8217;s
TDMA transmission time slot, buffering may be required when an
application on one node tries to send data on the network during the
transmission slot of a different node.  In this case, the data would
need to be buffered on the application&#8217;s node and would therefore
incur additional buffering delay.  If this TDMA schedule is not
integrated into the analysis of the network resources, the additional
buffer space required may exceed the buffer space allocation given to
the application or the buffering delay may exceed the application&#8217;s
acceptable latency.</p>
<p>So far, the description of the system provided network service profile
(<img class="math" src="_images/math/380e32ec071686ecc085988bde7ac1814b342625.png" alt="p[t]=y"/>), has been abstracted as simply the available
bandwidth as a function of time integrated to produce the amount of
data serviced as a function of time. We show how to model and analyze
the network&#8217;s lower-level TDMA MAC protocol using our network modeling
semantics.  We then derive general formulas for determining the affect
TDMA has on buffer size and delay predictions.</p>
<p>As an example TDMA system which benefits from our analysis techniques,
consider an application platform provided by a fractionated satellite
cluster.  A fractionated satellite cluster consists of many small
satellites that may each have different hardware, computing, and
communications capabilities.  These capabilities are provided to
distributed components of the satellite cluster&#8217;s applications.  Such
a system has the combined challenges of (1) being expensive to
develop, test, and deploy, (2) being very difficult to repair or
replace in the event of failure, and (3) having to support
mixed-criticality and possibly multiple levels of security
applications.  For this system, the network between these satellites
is a precious resource shared between each of the applications&#8217;
components in the cluster.  To ensure the stability of the network
resources, each satellite has a direct connection to every other
satellite and is assigned a slot in the TDMA schedule during which the
satellite may transmit.  Each TDMA slot has a sinusoidally
time-varying bandwidth profile which may differ from the other TDMA
slot bandwidth profiles.  The time-varying profile of the slot
bandwidth comes from the coupling between the radios&#8217; inverse-squared
bandwidth-as-a-function-of-distance and the satellites&#8217; sinusoidal
distance-as-a-function-of-orbital-position.</p>
<p>Such a system and applications necessitates design-time guarantees
about resource utilization and availability.  Applications which
utilize the satellite network need assurances that the network
resources they require during each part of the orbital period will be
satisfied.  To provide these assurances, we provide the application
developers and system integrators the ability to specify and analyze
the network profiles as (possibly periodic) functions of time.
Furthermore, the requirement for accurate predictions necessitates the
incorporation of the TDMA scheduling and bandwidth profiling into the
network modeling and analysis tools.</p>
<p>TDMA schedules can be described by their period, their number of
slots, and the bandwidth available to each slot as a function of time.
For simplicity of explanation, we assume that each node only gets a
single slot in the TDMA period and all slots have the same length, but
the results are valid for all static TDMA schedules.  Note that each
slot still has a bandwidth profile which varies as a function of time
and that each slots may have a different bandwidth profile.  In a
given TDMA period (<img class="math" src="_images/math/6d42c88506b8da39a2a23653aecbfb7c29728063.png" alt="T"/>), the node can transmit a certain number
of bits governed by its slot length (<img class="math" src="_images/math/cf9587087c31a9c170c37ca7b177cbba7dd214b8.png" alt="t_{slot}"/>) and the slot&#8217;s
available bandwidth (<img class="math" src="_images/math/b5aaef650b359f1ef3ce8bd77a565a360c1cd610.png" alt="bw_{slot}"/>).  During the rest of the TDMA
period, the node&#8217;s available bandwidth is <img class="math" src="_images/math/74c081db590f3d35421c1f6b9afd4cdda36ee210.png" alt="0"/>.  This scheduling
has the effect of amortizing the node&#8217;s slot bandwidth into an
effective bandwidth of <img class="math" src="_images/math/7a2a5b141cbf3fe40c9626c35cf419cd5206e4a2.png" alt="bw_{effective} = bw_{slot} *
\dfrac{t_{slot}}{T}"/>.  The addition of the TDMA scheduling can affect
the buffer and delay calculations, based on the slot&#8217;s bandwidth, the
number of slots, and the slot length.  The maximum additional delay is
<img class="math" src="_images/math/aa52ef22198842540e73e53c88f8e67cdcfefad8.png" alt="\Delta_{delay} = T - t_{slot}"/>, and the maximum additional
buffer space is <img class="math" src="_images/math/40f6366fdabeedf2fa9a799fb062c1797e6011f7.png" alt="\Delta_{buffer} = \Delta_{delay} *
bw_{effective}"/>.  These deviations are shown below.  Clearly,
<img class="math" src="_images/math/e2678b0d7673a4e642bca4131b013ff653c6da9d.png" alt="\Delta_{delay}"/> is bounded by <img class="math" src="_images/math/6d42c88506b8da39a2a23653aecbfb7c29728063.png" alt="T"/> and
<img class="math" src="_images/math/78014df4d22e583ce4060d725331e353dbda529d.png" alt="\Delta_{buffer}"/> is governed by <img class="math" src="_images/math/cf9587087c31a9c170c37ca7b177cbba7dd214b8.png" alt="t_{slot}"/>.  Therefore,
because <img class="math" src="_images/math/cf9587087c31a9c170c37ca7b177cbba7dd214b8.png" alt="t_{slot}"/> is dependent on <img class="math" src="_images/math/6d42c88506b8da39a2a23653aecbfb7c29728063.png" alt="T"/>, minimizing
<img class="math" src="_images/math/6d42c88506b8da39a2a23653aecbfb7c29728063.png" alt="T"/> minimizes both the maximum extra delay and maximum extra
buffer space.</p>
<table border="1" class="docutils">
<colgroup>
<col width="49%" />
<col width="51%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">In-Phase TDMA profile vs abstract</th>
<th class="head">Out-of-Phase TDMA Profile vs abstract</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><a class="first last reference internal image-reference" href="_images/tdma_phase0.png"><img alt="_images/tdma_phase0.png" src="_images/tdma_phase0.png" style="height: 200px;" /></a>
</td>
<td><a class="first last reference internal image-reference" href="_images/tdma_phase1.png"><img alt="_images/tdma_phase1.png" src="_images/tdma_phase1.png" style="height: 200px;" /></a>
</td>
</tr>
</tbody>
</table>
<p>Following from this analysis, we see that if: (1) the TDMA effective
bandwidth profile is provided as the abstract system network service
profile, and (2) the TDMA period is much smaller than the duration of
the shortest profile interval; then the system with explicit modeling
of the TDMA schedule has similar predicted application network
characteristics as the abstract system.  Additionally, the maximum
deviation formulas derived above provide a means for application
developers to analyze the their application on a TDMA system without
explicitly integrating the TDMA model into the system profile model.</p>
</div>
<div class="section" id="compositional-analysis">
<span id="id2"></span><h2>Compositional Analysis<a class="headerlink" href="#compositional-analysis" title="Permalink to this headline">¶</a></h2>
<p>Now that we have precise network performance analysis for aggregate
profiles or singular profiles on individual nodes of the network, we must
determine how best to compose these profiles and nodes together to
analyze the overall system.  The aim of this work is to allow the profiles
from each application to be analyzed separately from the other profiles
in the network, so that application developers and system integrators
can derive meaningful perfomance predictions for specific
applications.  For this goal, let us define:</p>
<div class="line-block">
<div class="line"><strong>Compositionality:</strong> [<a class="reference internal" href="#sifakis2002">sifakis2002</a>]</div>
<div class="line-block">
<div class="line">A system is compositional if its properties can be derived from</div>
<div class="line">the properties of its components and how they are interconnected.</div>
<div class="line"><br /></div>
</div>
</div>
<div class="line-block">
<div class="line"><strong>Composability:</strong> [<a class="reference internal" href="#sifakis2002">sifakis2002</a>]</div>
<div class="line-block">
<div class="line">A component is composable if its properties do not change</div>
<div class="line">when the component is composed with other components.</div>
<div class="line"><br /></div>
</div>
</div>
<p>For our analysis techniques to be compositional, an application&#8217;s
required profile must be analyzable individually without requiring
aggregation with the rest of the required profiles in the system.
This means that the system&#8217;s performance, i.e. the peformance of all
the applications on the system, can be determined by analyzing the
performance of each application individually.</p>
<p>For this compositionality, we must not only define mathematical
operations which allow us to aggregate and separate profiles with/from
each other, but also the semantics of how these profiles are composed
with one another.  These semantics govern the relation between
required profiles, specifically governing the distribution of their
shared node&#8217;s provided profile between each other.  For our
compositional analysis, we defined that each required profile in the
system be given a unique priority, <img class="math" src="_images/math/73f5e249c88b2b3068263480f576b051cb5c4f6e.png" alt="U"/>, with the relation that a
profile <img class="math" src="_images/math/26a00c0666e9094d8aac94f0ef300011af9b38a5.png" alt="P_1"/> has a higher priority than profile <img class="math" src="_images/math/6534eb155fcde09dbe8489e513d1925f86997578.png" alt="P_2"/>
<em>iff</em> <img class="math" src="_images/math/b70132060f3b882366b3a6fa59cdd0cdfa72019e.png" alt="U_{P_1} &lt; U_{P_2}"/>.  Using this priority relation, we can
define that a profile <img class="math" src="_images/math/0d28dc7d569a7d28cd0a992d11980e9462908d35.png" alt="P_i"/> does not receive any capacity from
its node at time <img class="math" src="_images/math/ef9270877405055756d345facd044e4ab297f858.png" alt="t"/> until all other profiles with priority
<img class="math" src="_images/math/b712a53a8674ce08bfb47928271cae4feb4d5d07.png" alt="&lt; U_{P_i}"/> have received their requested capacity from the
node at <img class="math" src="_images/math/ef9270877405055756d345facd044e4ab297f858.png" alt="t"/>.  If the node does not have enough capacity at
<img class="math" src="_images/math/ef9270877405055756d345facd044e4ab297f858.png" alt="t"/> to service <img class="math" src="_images/math/0d28dc7d569a7d28cd0a992d11980e9462908d35.png" alt="P_i"/>, then the data <img class="math" src="_images/math/0d28dc7d569a7d28cd0a992d11980e9462908d35.png" alt="P_i"/> attempted
to send at <img class="math" src="_images/math/ef9270877405055756d345facd044e4ab297f858.png" alt="t"/> will be placed into its buffer, to be sent at a
time when the node has available bandwidth for <img class="math" src="_images/math/0d28dc7d569a7d28cd0a992d11980e9462908d35.png" alt="P_i"/>.</p>
<p>This priority relation for compositional analysis is similar to the
task priority used for schedulability analysis in Real-Time Calculus,
mentioned in <a class="reference internal" href="background.html#rtc"><span>Real Time Calculus</span></a>.  Similarly to RTC, this priority relation and
compositionality allow us to capture the effects independent profiles
have on each other when they share the same network resources.  Just
as RTC based its priority relation and computation scheduling on a
fixed-priority scheduler, our priority relation and resource allotment
is based on the network Quality-of-Service (QoS) management provided
by different types of networking infrastructure.  One such mechanism
for implementing this type of priority-based network resource
allocation is through the use of the DiffServ Code Point
(DSCP)[<a class="reference internal" href="#rfc2474">RFC2474</a>].  The DSCP is a bit-field in all packets which have
an Internet Protocol (IP) header which allows the packet to be
assigned a specific class for per-hop routing behavior.  Routers and
forwarders in the network group packets according to their DSCP class
and provide different service capacities to each class.  For example,
the <em>Expedited Forwarding</em> [<a class="reference internal" href="#rfc3246">RFC3246</a>] class receives strict priority
queuing above all other traffic, which makes it a suitable
implementation of this type of resource allocation.</p>
<p>Mathematically, compositionality requires that we be able to add and
subtract profiles from each other, for instance to determine the
remaining service capacity of a node available for a profile
<img class="math" src="_images/math/0d28dc7d569a7d28cd0a992d11980e9462908d35.png" alt="P_i"/> after it serves all profiles with a higher priority.  The
remaining capacity, <img class="math" src="_images/math/b28792cd4c5e2f5fee5373ad329bff567f68055a.png" alt="P_P'"/>, of the node after it services
<img class="math" src="_images/math/0d28dc7d569a7d28cd0a992d11980e9462908d35.png" alt="P_i"/> is given as:</p>
<div class="math">
<p><img src="_images/math/a09d0ddd7194f476fa3e3b672c09b33e7f4fa391.png" alt="P_P' = P_P - ( P_i \otimes P_P )"/></p>
</div><p>Where</p>
<ul class="simple">
<li><img class="math" src="_images/math/8aac03b267c0d6a8b10bada564e2169d6a73179a.png" alt="P_P"/> is the capacity available to profile <img class="math" src="_images/math/0d28dc7d569a7d28cd0a992d11980e9462908d35.png" alt="P_i"/></li>
</ul>
<p>We are finalizing the design and code for tests which utilize the DSCP
bit(s) setting on packet profiles to show that such priority-based
analysis techniques are correct for these types of systems.</p>
</div>
<div class="section" id="delay-analysis">
<span id="id3"></span><h2>Delay Analysis<a class="headerlink" href="#delay-analysis" title="Permalink to this headline">¶</a></h2>
<p>When dealing with queueing systems (esp. networks) where precise
design-time guarantees are required, the delay in the links of the
network must be taken into account.</p>
<p>The delay is modeled as a continuous function of latency (seconds)
versus time.  In the profiles, the latency is specified discretely as
<img class="math" src="_images/math/91afa6a0c10f8e9475164168f94fe6080b3bc3f9.png" alt="(time, latency)"/> pairs, and is interpolated linearly between
successive pairs.</p>
<p>Using these latency semantics, the delay convolution of a profile
becomes</p>
<div class="math">
<p><img src="_images/math/58781499305d2973dc0695f586fc8daa50ad2fe3.png" alt="r[t + \delta[t]] = l[t]"/></p>
</div><p>Where</p>
<ul class="simple">
<li><img class="math" src="_images/math/c52328274518603a2cc478a4db8925ffa035faed.png" alt="l[t]"/> is the <em>link</em> profile describing the data as a function
of time as it enters the link</li>
<li><img class="math" src="_images/math/2a0a2f67e07caa3e17e5f8f645b78f5cad3812dd.png" alt="\delta[t]"/> is the <em>delay</em> profile describing the latency as a
function of time on the link</li>
<li><img class="math" src="_images/math/8d85052c33844b2074fa63b28dcb671b60af6411.png" alt="r[t]"/> is the <em>received</em> profile describing the data as a
function of time as it is received at the end of the link</li>
</ul>
<p>When analyzing delay in a periodic system, it is important to
determine the effects of delay on the system&#8217;s periodicity.  We know
that the period of the periodic profiles is defined by the time
difference between the start of the profile and the end of the
profile.  Therefore, we can show that if the time difference between
the <strong>start time</strong> of the <em>received</em> profile and the <strong>end time</strong> of
the <em>received</em> profile is the same as the <strong>period</strong> of the <em>link</em>
profile, the periodicity of the profile is unchanged.</p>
<ul class="simple">
<li><img class="math" src="_images/math/d3a93ce5fdd86a1a6cea538e4b3ad7616156ff25.png" alt="T_p"/> is the period of the <em>link</em> profile</li>
<li><img class="math" src="_images/math/bb9f50d66397f6337f4cfddb0ca20a1977e482ce.png" alt="r[t + \delta[t]]"/> is the beginning of the <em>received</em> profile</li>
<li><img class="math" src="_images/math/c80e1df5ca2c0f162a61382b667eecc1026dc37f.png" alt="r[(t + T_p) + \delta[(t + T_p)]]"/> is the end of the
<em>received</em> profile</li>
</ul>
<p>We determine the condition for which <img class="math" src="_images/math/b1021500b5fe6128b7c4c8eb175cb1585710e999.png" alt="(t_{end}) - (t_{start}) =
T_p"/>:</p>
<div class="math">
<p><img src="_images/math/46245c7be404e773c109d1748baac82a5d546fcd.png" alt="(T_p + t + \delta[T_p + t]) - (t + \delta[t]) &amp;= T_p \\
T_p + \delta[T_p + t] - \delta[t] &amp;= T_p \\
\delta[T_p + t] - \delta[t] &amp;= 0\\
\delta[T_p + t] &amp;= \delta[t]"/></p>
</div><p>Which is just confirms that the periodicity of the delayed profile is
unchanged <em>iff</em> the latency profile is <strong>periodic</strong>, i.e.</p>
<div class="math">
<p><img src="_images/math/dc90d07f427d8cceca6257bcd610427067e32b93.png" alt="\delta[t] = \delta[t + k*T_p], \forall k\in\mathbb{N} &gt; 0"/></p>
</div></div>
<div class="section" id="routing-analysis">
<span id="id4"></span><h2>Routing Analysis<a class="headerlink" href="#routing-analysis" title="Permalink to this headline">¶</a></h2>
<p>Having discussed profile composition and the affects of delaying a
profile, we can address one more aspect of system analysis: <em>routing</em>.
For this analysis we will specifically focus on statically routed
networks.</p>
<p>By incorporating both the latency analysis with the compositional
operations we developed, we can perform system-level analysis of profiles
which are routed by nodes of the system.  In this paradigm, nodes can
transmit/receive their own data, i.e. they can host applications which
act as data sources or sinks, as well as act as routers for profiles from
and to other nodes.  To make such a system amenable to analysis we
must ensure that we know the routes the profiles will take at design
time, i.e. the routes in the network are static and known or
calculable.  Furthermore, we must, for the sake of profile composition as
decribed above, ensure that each profile has a priority that is unique
within the network which governs how the transmitting and routing
nodes handle the profile&#8217;s data.</p>
<p>Let us define the system configuration <img class="math" src="_images/math/2bcc65482aa8e15cd4c9e9f2542451fb4e971a91.png" alt="C"/> as:</p>
<div class="math">
<p><img src="_images/math/1665b44bb6ec1578353806fafa7c9f5e674abe68.png" alt="C = \{\{P_S\},\{N\},\{R\}\}"/></p>
</div><p>Where</p>
<ul class="simple">
<li><img class="math" src="_images/math/a4dc88a5769b894edba3cd17bae8090a07e901a0.png" alt="\{P_S\}"/> is the <em>set</em> of all <em>sender</em> profiles in the system
configuration</li>
<li><img class="math" src="_images/math/965f1d1188ca407fa91a1324b28e9ccbfad460e5.png" alt="\{N\}"/> is the <em>set</em> of all <em>nodes</em> in the system configuration, and</li>
<li><img class="math" src="_images/math/3683f44cdad2d76441db6cc320ade9b5b51f01da.png" alt="\{R\}"/> is the <em>set</em> of all <em>routes</em> in the system configuration</li>
</ul>
<p>We define a profile <img class="math" src="_images/math/f48b617185733d8dd6712643f1ab17c736661a06.png" alt="P"/> as:</p>
<div class="math">
<p><img src="_images/math/c54f6b742ee67d299e31508af8bb75bd840fbd5c.png" alt="P = \{N_I,K,T,F,U,\{(t,R_D,D,L)\}\}"/></p>
</div><p>Where</p>
<ul class="simple">
<li><img class="math" src="_images/math/2705e64f930f972a3b115371e168a346474acbff.png" alt="N_I"/> is the <em>Node ID</em> to which the profile applies</li>
<li><img class="math" src="_images/math/28e003020d0ae96250b302d7d779c791f183f707.png" alt="K"/> is the <em>kind</em> of the profile, where
<img class="math" src="_images/math/e00ae89710542dd5ac2331c713b84ccf72150e6a.png" alt="K\in\{provided,required,receiver\}"/></li>
<li><img class="math" src="_images/math/6d42c88506b8da39a2a23653aecbfb7c29728063.png" alt="T"/> is the <em>period</em> of the profile</li>
<li><img class="math" src="_images/math/183421431fcc0a42e22f825a33dcc3c51607fa6e.png" alt="F"/> is the <em>flow ID</em> of the profile, where two profiles,
<img class="math" src="_images/math/27e729d0949488c03d6b072196dfd11c4677399f.png" alt="P_1,P_2"/> belong to the same flow <em>iff</em>
<img class="math" src="_images/math/17eb4fd4601d9534dbab75e6269acf0070efece0.png" alt="F_{P_1}==F_{P_2}"/></li>
<li><img class="math" src="_images/math/73f5e249c88b2b3068263480f576b051cb5c4f6e.png" alt="U"/> is the <em>priority</em> of the profile, where profile
<img class="math" src="_images/math/26a00c0666e9094d8aac94f0ef300011af9b38a5.png" alt="P_1"/> has a higher priority than profile <img class="math" src="_images/math/6534eb155fcde09dbe8489e513d1925f86997578.png" alt="P_2"/> <em>iff</em>
<img class="math" src="_images/math/b70132060f3b882366b3a6fa59cdd0cdfa72019e.png" alt="U_{P_1} &lt; U_{P_2}"/>, and</li>
<li><img class="math" src="_images/math/3a539cc9333e612eacb291652faa876d4f4a7425.png" alt="\{(t,R_D,D,L)\}"/> is a <em>set</em> of <img class="math" src="_images/math/114836fcecfead07cc75d93f059620e5ed764848.png" alt="(time, data\ rate,
data, latency)"/> tuples describing how each of <img class="math" src="_images/math/6b8c45efdcdccdad4cc24eaad3e07e61705426e6.png" alt="\{data\ rate,
data, latency\}"/> vary with respect to time.  Semantically, the
<img class="math" src="_images/math/87c2faaa595684b1a0ec3c5a6fee140ce3220be9.png" alt="data\ rate"/> is constant between any two successive values of
<img class="math" src="_images/math/ef9270877405055756d345facd044e4ab297f858.png" alt="t"/>, while the <img class="math" src="_images/math/7373470a3f752ced5c52b35f0247cd49be63b14b.png" alt="data"/> and <img class="math" src="_images/math/7590f8f2ae3463978567357f685c7ef8065f330c.png" alt="latency"/> are <em>linearly
interpolated</em> during the same interval.  The initial profile
specification does not have the <img class="math" src="_images/math/7373470a3f752ced5c52b35f0247cd49be63b14b.png" alt="data"/> field; <img class="math" src="_images/math/7373470a3f752ced5c52b35f0247cd49be63b14b.png" alt="data"/> is
calculated based on <img class="math" src="_images/math/87c2faaa595684b1a0ec3c5a6fee140ce3220be9.png" alt="data\ rate"/>.</li>
</ul>
<p>Then we define a node <img class="math" src="_images/math/75e27f04188974063be3230dca208cd495b77ce1.png" alt="N"/> as:</p>
<div class="math">
<p><img src="_images/math/9d9fc73d16271dcee9c70c50d281ae09cf40590e.png" alt="N = \{I,P_P,\{P_R\}\}"/></p>
</div><p>Where</p>
<ul class="simple">
<li><img class="math" src="_images/math/5d9e7b2aec3287330051a115f2ea3cdc8c7a6587.png" alt="I"/> is the <em>ID</em> of the node</li>
<li><img class="math" src="_images/math/8aac03b267c0d6a8b10bada564e2169d6a73179a.png" alt="P_P"/> is the <em>provided</em> profile of the node, and</li>
<li><img class="math" src="_images/math/8276945460b005875b6df89c9fb30ad46a7d839b.png" alt="\{P_R\}"/> is the <em>set</em> of all <em>receiver</em> profiles on the node</li>
</ul>
<p>And finally, we define a route <img class="math" src="_images/math/9d86170e7de539c0ff999de09621ee0c7b6c8ed0.png" alt="R"/> as:</p>
<div class="math">
<p><img src="_images/math/176a9ae50c289679f2afee45f09b4032f892ab47.png" alt="R = \{N_{I_1},N_{I_2},...,N_{I_N}\}"/></p>
</div><p>Where</p>
<div class="math">
<p><img src="_images/math/120c275657b165a069f50e7f448be4fb60d8c541.png" alt="\forall N_X,N_Y \subset N, \exists! R_{X,Y} = \{N_{I_X},...,N_{I_Y}\}"/></p>
</div><p>We can then run the following algorithm to iteratively analyze the
system:</p>
<div class="highlight-C#"><div class="highlight"><pre><span class="n">analyze</span><span class="p">(</span> <span class="n">sender_profiles</span> <span class="p">)</span>
<span class="p">{</span>
  <span class="n">sender_profiles</span> <span class="p">=</span> <span class="n">sorted</span><span class="p">(</span><span class="n">sender_profiles</span><span class="p">,</span> <span class="n">priority</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">required_profile</span> <span class="k">in</span> <span class="n">sender_profiles</span>
  <span class="p">{</span>
    <span class="n">transmitted_nodes</span> <span class="p">=</span> <span class="n">list</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">receiver_profile</span> <span class="k">in</span> <span class="n">required_profile</span><span class="p">.</span><span class="n">receiver_profiles</span><span class="p">()</span>
    <span class="p">{</span>
      <span class="n">route</span> <span class="p">=</span> <span class="n">getRoute</span><span class="p">(</span><span class="n">required_profile</span><span class="p">,</span> <span class="n">receiver_profile</span><span class="p">)</span>
      <span class="k">for</span> <span class="n">node</span> <span class="k">in</span> <span class="n">route</span>
      <span class="p">{</span>
        <span class="k">if</span> <span class="n">node</span> <span class="k">in</span> <span class="n">transmitted_nodes</span> <span class="n">and</span> <span class="n">multicast</span> <span class="p">==</span> <span class="k">true</span>
        <span class="p">{</span>
          <span class="k">continue</span>
        <span class="p">}</span>
        <span class="n">provided_profile</span> <span class="p">=</span> <span class="n">node</span><span class="p">.</span><span class="n">provided_profile</span>

        <span class="n">output_profile</span> <span class="p">=</span> <span class="n">convolve</span><span class="p">(</span><span class="n">required_profile</span><span class="p">,</span> <span class="n">provided_profile</span><span class="p">)</span>
        <span class="n">remaining_profile</span> <span class="p">=</span> <span class="n">provided_profile</span> <span class="p">-</span> <span class="n">output_profile</span>
        <span class="n">received_profile</span> <span class="p">=</span> <span class="n">delay</span><span class="p">(</span><span class="n">output_profile</span><span class="p">,</span> <span class="n">provided_profile</span><span class="p">)</span>

        <span class="n">node</span><span class="p">.</span><span class="n">provided_profile</span> <span class="p">=</span> <span class="n">remaining_profile</span>
        <span class="n">required_profile</span> <span class="p">=</span> <span class="n">received_profile</span>
        <span class="n">transmitted_nodes</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
      <span class="p">}</span>
      <span class="n">receiver_received_profile</span> <span class="p">=</span> <span class="n">convolve</span><span class="p">(</span><span class="n">required_profile</span><span class="p">,</span> <span class="n">receiver_profile</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In this algorithm, the remaining capacity of the node is provided to
each profile with a lower priority iteratively.  Because of this
iterative recalculation of node provided profiles based on routed
profiles, we directly take into account the effect of multiple
independent profiles traversing the same router; the highest priority
profile receives as much bandwidth as the router can give it, the next
highest priority profile receives the remaining bandwidth, and so on.</p>
<p>We take care of matching all senders to their respective receivers,
and ensure that if the system supports multicast, a no retransmissions
occur; only nodes which must route the profile to a new part of the
network retransmit the data.  However, if the system does not support
multicast, then the sender must issue a separate transmission, further
consuming network resources.  In this way, lower-level transport
capabilities can be at least partially accounted for by our analysis.</p>
<p>We have implmented these functions for statically routed network
analysis into our tool, which automatically parses the profiles, the
network configuration and uses the algorithm and the implemented
mathematics to iteratively analyze the network.  Analytical results
for example systems will be provided when the experimental results can
be used as a comparison.</p>
<p>We are finishing the design and development of code which will allow
us to run experiments to validate our routing analysis results.  They
will be complete in the next two weeks.</p>
<table class="docutils citation" frame="void" id="sifakis2002" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[sifakis2002]</td><td>G. Goessler, J. Sifakis, &#8220;Composition for
Component-Based Modeling,&#8221; Springer, Formal Methods
for Components and Objects, 2003.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="rfc2474" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[RFC2474]</td><td>K. Nichols, Cisco Systems, et al., &#8220;Definition of the
Differentiated Services Field (DS Field) in the IPv4 and
IPv6 Headers,&#8221; IETF, RFC 2474, Dec.
1998. [Online]. Available: <a class="reference external" href="https://tools.ietf.org/html/rfc2474">https://tools.ietf.org/html/rfc2474</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="rfc3246" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[RFC3246]</td><td>B. Davie, A. Charny, et al., &#8220;An Expedited Forwarding
PHB (Per-Hop Behavior),&#8221; IETF, RFC 3246, Mar.
2002. [Online]. Available: <a class="reference external" href="https://tools.ietf.org/html/rfc3246">https://tools.ietf.org/html/rfc3246</a></td></tr>
</tbody>
</table>
</div>
</div>


          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="run-time.html" class="btn btn-neutral float-right" title="Run Time Results" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="results.html" class="btn btn-neutral" title="Precise Network Performance Prediction : Results" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015, finger563.
    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
  
 
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-61341323-1', 'auto');
  ga('send', 'pageview');
</script>


</body>
</html>