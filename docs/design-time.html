

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Design Time Results &mdash; PNP2 0.2.0 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="./_static/custom.css" type="text/css" />
  

  
    <link rel="top" title="PNP2 0.2.0 documentation" href="index.html"/>
        <link rel="up" title="Precise Network Performance Prediction : Results" href="results.html"/>
        <link rel="next" title="Run Time Results" href="run-time.html"/>
        <link rel="prev" title="Precise Network Performance Prediction : Results" href="results.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        

        
          <a href="index.html" class="icon icon-home"> PNP2
        

        
        </a>

        
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

        
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
          
          
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="background.html">Background: Network Performance Analysis</a><ul>
<li class="toctree-l2"><a class="reference internal" href="background.html#min-plus-calculus">Min-Plus Calculus</a></li>
<li class="toctree-l2"><a class="reference internal" href="background.html#network-calculus">Network Calculus</a></li>
<li class="toctree-l2"><a class="reference internal" href="background.html#real-time-calculus">Real Time Calculus</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="math.html">Precise Network Performance Prediction : Theory</a><ul>
<li class="toctree-l2"><a class="reference internal" href="math.html#mathematical-formalism">Mathematical Formalism</a></li>
<li class="toctree-l2"><a class="reference internal" href="math.html#assumptions-involved">Assumptions Involved</a></li>
<li class="toctree-l2"><a class="reference internal" href="math.html#factors-impacting-analysis">Factors Impacting Analysis</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="results.html">Precise Network Performance Prediction : Results</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="">Design Time Results</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#periodic-system-analysis">Periodic System Analysis</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#proving-the-minimum-analysis-for-system-stability">Proving the Minimum Analysis for System Stability</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#comparison-with-nc-rtc">Comparison with NC/RTC</a></li>
<li class="toctree-l3"><a class="reference internal" href="#analysis-of-tdma-scheduling">Analysis of TDMA Scheduling</a></li>
<li class="toctree-l3"><a class="reference internal" href="#compositional-analysis">Compositional Analysis</a></li>
<li class="toctree-l3"><a class="reference internal" href="#delay-analysis">Delay Analysis</a></li>
<li class="toctree-l3"><a class="reference internal" href="#routing-analysis">Routing Analysis</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="run-time.html">Run Time Results</a><ul>
<li class="toctree-l3"><a class="reference internal" href="run-time.html#middleware-integrated-measurement-detection-and-enforcement">Middleware-integrated Measurement, Detection, and Enforcement</a></li>
<li class="toctree-l3"><a class="reference internal" href="run-time.html#distributed-denial-of-service-ddos-detection">Distributed Denial of Service (DDoS) Detection</a></li>
</ul>
</li>
</ul>
</li>
</ul>

          
        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">PNP2</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
          <li><a href="results.html">Precise Network Performance Prediction : Results</a> &raquo;</li>
      
    <li>Design Time Results</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/design-time.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document">
            
  <div class="section" id="design-time-results">
<span id="design-time"></span><h1>Design Time Results<a class="headerlink" href="#design-time-results" title="Permalink to this headline">¶</a></h1>
<p>These results provide a methodology and a means for application
developers and system integrators to determine conservative, precise,
tightly bounded performance metrics for distributed networked
applications and systems at design time.  The contributions of this
work are broken into sections by topic:</p>
<ul class="simple">
<li><a class="reference internal" href="#periodic-system-analysis"><span>Periodic System Analysis</span></a></li>
<li><a class="reference internal" href="#periodic-analysis-proof"><span>Proving the Minimum Analysis for System Stability</span></a></li>
<li><a class="reference internal" href="#nc-comparison"><span>Comparison with NC/RTC</span></a></li>
<li><a class="reference internal" href="#tdma-analysis"><span>Analysis of TDMA Scheduling</span></a></li>
<li><a class="reference internal" href="#compositional-analysis"><span>Compositional Analysis</span></a></li>
<li><a class="reference internal" href="#delay-analysis"><span>Delay Analysis</span></a></li>
<li><a class="reference internal" href="#routing-analysis"><span>Routing Analysis</span></a></li>
</ul>
<div class="section" id="periodic-system-analysis">
<span id="id1"></span><h2>Periodic System Analysis<a class="headerlink" href="#periodic-system-analysis" title="Permalink to this headline">¶</a></h2>
<p>One subset of systems which we would like to analyze are periodic
systems, since many systems in the real world exhibit some form of
periodicity, e.g. satellites in orbit, traffic congestion patterns,
power draw patterns.  We define systems to be periodic if the data
production rate (or consumption rate) of the system is a periodic
function of time.  The time-integral of these periodic data
consumption/production rates is the cumulative data
production/consumption of the system.  These cumulative functions are
called <em>repeating</em>.</p>
<p>Given that the required data profile and system data service profile
are <em>repeating</em>, we must determine the periodicity of the output
profile.  If we can show that the output profile similarly repeats,
then we can show that the system has no unbounded buffer growth.
First, let us look at the profile behavior over the course of its
first two periods of activity.</p>
<p>We will examine two systems, <em>system (1)</em> and <em>system (2)</em>.  Firstly,
examine <em>(1)</em>, shown below (note: you can click on the images to open
them in a larger format):</p>
<table border="1" class="docutils">
<colgroup>
<col width="49%" />
<col width="51%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">System <em>(1)</em> Bandwidth for 1 Period</th>
<th class="head">System <em>(1)</em> Data for 1 Period</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><a class="first last reference internal image-reference" href="_images/1-period-system-bw.png"><img alt="_images/1-period-system-bw.png" src="_images/1-period-system-bw.png" style="height: 200px;" /></a>
</td>
<td><a class="first last reference internal image-reference" href="_images/1-period-system-data.png"><img alt="_images/1-period-system-data.png" src="_images/1-period-system-data.png" style="height: 200px;" /></a>
</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="49%" />
<col width="51%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">System <em>(1)</em> Bandwidth for 2 Periods</th>
<th class="head">System <em>(1)</em> Data for 2 Periods</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><a class="first last reference internal image-reference" href="_images/2-period-system-bw.png"><img alt="_images/2-period-system-bw.png" src="_images/2-period-system-bw.png" style="height: 200px;" /></a>
</td>
<td><a class="first last reference internal image-reference" href="_images/2-period-system-data.png"><img alt="_images/2-period-system-data.png" src="_images/2-period-system-data.png" style="height: 200px;" /></a>
</td>
</tr>
</tbody>
</table>
<p>We notice that for this example system, the second period output
profile is not an exact copy of the first (most easily seen by
examining the bandwidth plots), and yet the required buffer size is
still the same as it was when analyzing the system over one period.
Furthermore, by running the analysis over even larger number of
periods, we can determine (not plotted here for space and
readability), that the predicted buffer size does not change no matter
how many periods we analyze for this system.</p>
<p>Let us look at a system where this is not the case before we begin the
analysis of such system characteristics.</p>
<table border="1" class="docutils">
<colgroup>
<col width="49%" />
<col width="51%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">System <em>(2)</em> Bandwidth for 1 Period</th>
<th class="head">System <em>(2)</em> Data for 1 Period</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><a class="first last reference internal image-reference" href="_images/1-period-unstable-bw.png"><img alt="_images/1-period-unstable-bw.png" src="_images/1-period-unstable-bw.png" style="height: 200px;" /></a>
</td>
<td><a class="first last reference internal image-reference" href="_images/1-period-unstable-data.png"><img alt="_images/1-period-unstable-data.png" src="_images/1-period-unstable-data.png" style="height: 200px;" /></a>
</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="49%" />
<col width="51%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">System <em>(2)</em> Bandwidth for 2 Periods</th>
<th class="head">System <em>(2)</em> Data for 2 Periods</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><a class="first last reference internal image-reference" href="_images/2-period-unstable-bw.png"><img alt="_images/2-period-unstable-bw.png" src="_images/2-period-unstable-bw.png" style="height: 200px;" /></a>
</td>
<td><a class="first last reference internal image-reference" href="_images/2-period-unstable-data.png"><img alt="_images/2-period-unstable-data.png" src="_images/2-period-unstable-data.png" style="height: 200px;" /></a>
</td>
</tr>
</tbody>
</table>
<p>Notice in system <em>(2)</em>, the first period analysis predicted the same
buffer size and delay as system <em>(1)</em>, but when analyzing two periods
the predicted buffer size changed.  Clearly the behavior of the system
is changing between these two periods.  If we continue to analyze more
periods of system <em>(2)</em>, as we did with system <em>(1)</em>, we&#8217;ll find the
unfortunate conclusion that the predicted buffer size increases with
every period we add to the analysis.</p>
<p>We have discovered a system level property that can be calculated from
these profiles, but we must determine what it means and how it can be
used.  First, we see that in system <em>(1)</em>, the predicted required
buffer size does not change regarless of the number of periods over
which we analyze the system.  Second, we see that for system <em>(2)</em>,
the predicted required buffer size changes depending on how many
periods of activity we choose for our analysis window.  Third, we see
that the second period of system <em>(2)</em> contains the larger of the two
predicted buffer sizes.  These observations (with our understanding of
deterministic periodic systems) lead us to the conclusion: system
<em>(2)</em> can no longer be classified as periodic, since its behavior is
not consistent between its periods.  Furthermore, because the required
buffer size predicted for system system <em>(2)</em> continually increases,
we can determine that the system is in fact <em>unstable</em> due to
unbounded buffer growth.</p>
<div class="section" id="proving-the-minimum-analysis-for-system-stability">
<span id="periodic-analysis-proof"></span><h3>Proving the Minimum Analysis for System Stability<a class="headerlink" href="#proving-the-minimum-analysis-for-system-stability" title="Permalink to this headline">¶</a></h3>
<p>Let us now formally prove the assertion about system periodicity and
stability which has been stated above.  We will show that our analysis
results provide quantitative measures about the behavior of the system
and we will determine for how long we must analyze a system to glean
such behaviors.</p>
<p>Typically, periodicity is defined for functions as the equality:</p>
<div class="math">
<p><img src="_images/math/c334144f9896123b590c4cfccaa70ca012c95807.png" alt="x(t) = x(t + k * T), \forall k \in \mathbb{N} &gt; 0"/></p>
</div><p>but for our type of system analysis this cannot hold since we deal
with cumulative functions (of data vs. time).  Instead we must define
a these functions to be <strong>repeating</strong>, where a function is repeating
<em>iff</em>:</p>
<div class="math">
<p><img src="_images/math/30e4f8159751a8c913decd16c7a8703a205ebd79.png" alt="x(0) &amp;= 0 \text{  and}\\
x(t + k * T) &amp;= x(t) + k * x(T), \forall k \in \mathbb{N} &gt; 0"/></p>
</div><p>Clearly, a repeating function <img class="math" src="_images/math/188c175aac0a8a9c22499336711b5d7256407254.png" alt="x"/> is <strong>periodic</strong> <em>iff</em>
<img class="math" src="_images/math/20c77058fe03716b694fb60e36e18d8d2170c018.png" alt="x(T)=0"/>.  Note that repeating functions like the cumulative
data vs. time profiles we deal with, are the result of <strong>integrating</strong>
<em>periodic</em> functions, like the periodic bandwidth vs. time profiles we
use to describe application network traffic and system network
capacity.  All periodic functions, when integrated, produce repeating
functions and similarly, all repeating functions, when differentiated,
procduce periodic functions.</p>
<p>Now we will consider a deterministic, <em>repeating</em> queuing system
providing a data service function <img class="math" src="_images/math/11a85f3c69ae6702cb1d99d3de451913b8f84c04.png" alt="S"/> to input data function
<img class="math" src="_images/math/5d9e7b2aec3287330051a115f2ea3cdc8c7a6587.png" alt="I"/> to produce output data function <img class="math" src="_images/math/f3f716e1c56d5ebdca97bb1546662b9e96f5be07.png" alt="O"/>, where these
functions are <em>cumulative data versus time</em>.  At any time <img class="math" src="_images/math/ef9270877405055756d345facd044e4ab297f858.png" alt="t"/>,
the amount of data in the system&#8217;s buffer is given by <img class="math" src="_images/math/182fedb62e8623cd880abf38d211d0455fa2e477.png" alt="B_t"/>.
After servicing the input, the system has a remaining capacity
function <img class="math" src="_images/math/9d86170e7de539c0ff999de09621ee0c7b6c8ed0.png" alt="R"/>.</p>
<ul class="simple">
<li><img class="math" src="_images/math/a08ad3515eac0feebd61d7a1b6eaf157eedbdd3e.png" alt="S[t]"/> : the service function of the system, cumulative data
service capacity versus time</li>
<li><img class="math" src="_images/math/6d5f8ae3ceb47a2a475bb2f02fc8107d6ffb9b06.png" alt="I[t]"/> : the input data to the system, cumulative data versus
time</li>
<li><img class="math" src="_images/math/a4b883e2dcb9cf31b5a935b8539949ef4333dfc8.png" alt="O[t]"/> : the output data from the system, cumulative data
versus time</li>
<li><img class="math" src="_images/math/01cd005a7eb681a16f7d214ea489cee0570eca8f.png" alt="B[t]"/> : the amount of data in the system&#8217;s buffer at time
<img class="math" src="_images/math/ef9270877405055756d345facd044e4ab297f858.png" alt="t"/>, i.e. <img class="math" src="_images/math/2e3d35b2dc6e8c76e4412baaa21a1b190aed4d37.png" alt="I[t]-O[t]"/></li>
<li><img class="math" src="_images/math/2296df10353d0d24932ae9239bb1c004522bd7d2.png" alt="R[t]"/> : the remaining service capacity of the system after
servicing <img class="math" src="_images/math/5d9e7b2aec3287330051a115f2ea3cdc8c7a6587.png" alt="I"/>, i.e. <img class="math" src="_images/math/6e4faafd2b95bb8f49c163b2d0436418269ab2d7.png" alt="S[t] - O[t]"/></li>
</ul>
<p>Because <img class="math" src="_images/math/11a85f3c69ae6702cb1d99d3de451913b8f84c04.png" alt="S"/> and <img class="math" src="_images/math/5d9e7b2aec3287330051a115f2ea3cdc8c7a6587.png" alt="I"/> are deterministic and repeating, they
increase deterministically from period to period, i.e. given the
period <img class="math" src="_images/math/5ff95e0eeb56451cbcfe611d1c422c9381195596.png" alt="T_I"/> of <img class="math" src="_images/math/5d9e7b2aec3287330051a115f2ea3cdc8c7a6587.png" alt="I"/>,</p>
<div class="math">
<p><img src="_images/math/f6f17ef56dfd78aded3eb9a70efc05b9e251982e.png" alt="\forall t, \forall n \in \mathbb{N} &gt; 0 : I[t + n*T_I] =
I[t] + n*I[T_I]"/></p>
</div><p>Similarly, given the period <img class="math" src="_images/math/c1060ce177cee9b3af63aa8e847dbe201c1afab0.png" alt="T_S"/> of <img class="math" src="_images/math/11a85f3c69ae6702cb1d99d3de451913b8f84c04.png" alt="S"/>,</p>
<div class="math">
<p><img src="_images/math/e5b4dfc1d0a3e7ab61648bf6220ad3d01caee114.png" alt="\forall t, \forall n \in \mathbb{N} &gt; 0 : S[t + n*T_S] =
S[t] + n*S[T_S]"/></p>
</div><p>We can determine the hyperperiod of the system as the <img class="math" src="_images/math/e83965b2f16217c11c9dcb2f0a671f40da396ed3.png" alt="lcm"/> of
input function period and the service function period, <img class="math" src="_images/math/3856e38d70416a9b3dee493b4190ed04456c6428.png" alt="T_p =
lcm(T_S,T_I)"/>.</p>
<p>At the start of the system, <img class="math" src="_images/math/4e2677b4edfbb85a135b7807d780a44ffa83f052.png" alt="t=0"/>, the system&#8217;s buffer is empty,
i.e.  <img class="math" src="_images/math/f6a3588d85e5c4783a1151a85bdb615bb4d66db1.png" alt="B[0] = 0"/>.  Therefore, the amount of data in the buffer
at the end of the first period, <img class="math" src="_images/math/99a8de8b225ffd7a8236c5d0894b31d1ce616cc4.png" alt="t=T_p"/>, is the amount of data
that entered the system on input function <img class="math" src="_images/math/5d9e7b2aec3287330051a115f2ea3cdc8c7a6587.png" alt="I"/> but was not able
to be serviced by <img class="math" src="_images/math/11a85f3c69ae6702cb1d99d3de451913b8f84c04.png" alt="S"/>.  At the start of the next period, this
data will exist in the buffer.  Data in the buffer at the start of the
period can be compared to the system&#8217;s remaining capacity <img class="math" src="_images/math/9d86170e7de539c0ff999de09621ee0c7b6c8ed0.png" alt="R"/>,
since the remaining capacity of the system indicates how much extra
data it can transmit in that period.  Consider the scenario that the
system&#8217;s remaining capacity <img class="math" src="_images/math/9d86170e7de539c0ff999de09621ee0c7b6c8ed0.png" alt="R"/> is less than the size of the
buffer, i.e. <img class="math" src="_images/math/d196db590a966706d982ef4e085bf610163f423e.png" alt="R[T_p] &lt; B[T_p]"/>.  In this scenario,
<img class="math" src="_images/math/d122eaebcd3be7a2931e55b4f8a488d7fd88e9c2.png" alt="B[2*T_p] &gt; B[T_p]"/>, i.e. there will be more data in the buffer
at the end of the second period than there was at the end of the first
period.  Since the system is deterministic, for any two successive
periods, <img class="math" src="_images/math/b9a9df387042bbb0961875f39567147b9326c3e0.png" alt="n*T_p"/> and <img class="math" src="_images/math/819cd3c4776e788abaa849b87e2071c589d13d0f.png" alt="(n+1)*T_p"/>, <img class="math" src="_images/math/be3783ed63b7ea54b972111d1dec43c2dea7d6dc.png" alt="B[n*T_p] &gt;
B[(n+1)*T_p]"/>, which extends to:</p>
<div class="math">
<p><img src="_images/math/b32dffeddd6858728ce6aa1959a915155e7a9f39.png" alt="B[m*T_p] &gt; B[n*T_p], \forall m&gt;n&gt;0"/></p>
</div><p>implying that:</p>
<div class="math">
<p><img src="_images/math/b50abfbe06ba9876952e1d0cca84f9d8c99b41a8.png" alt="B[t] &lt; B[t + k*T_p], \forall k \in \mathbb{N} &gt; 0"/></p>
</div><p>meaning that the amount of data in the buffer versus time is <em>not
periodic</em>, therefore the amount of data in the system&#8217;s buffer
increases every period, i.e. the system has <em>unbounded buffer growth</em>.</p>
<p>If however, there is enough remaining capacity in the system to
service the data in the buffer, i.e. <img class="math" src="_images/math/f14219b37c6f7adadce486123a40ecf1f8514a45.png" alt="R[T_p] &gt;= B[T_p]"/>, then
<img class="math" src="_images/math/33d4f4dd02841f21b6856ee7772cc8d0f77c4bf3.png" alt="B[2*T_p] = B[T_p]"/>.  This relation means that if the remaining
capacity of the system that exists after all the period&#8217;s required
traffic has been serviced is equal to or larger than the size of the
buffer at the end of the period, then in the next period the system
will be able to service fully both the data in the buffer and the
period&#8217;s required traffic.  Since both the period&#8217;s traffic and the
buffer&#8217;s data will have been serviced in that period, the amount of
data in the buffer at the end of the period will be the same as the
amount of data that was in the buffer at the start of the
period. Similarly to above, since the system is deterministic, for any
two successive periods, <img class="math" src="_images/math/b9a9df387042bbb0961875f39567147b9326c3e0.png" alt="n*T_p"/> and <img class="math" src="_images/math/819cd3c4776e788abaa849b87e2071c589d13d0f.png" alt="(n+1)*T_p"/>,
<img class="math" src="_images/math/875277b8532466efb8412008d89be2dc4e8d5ee9.png" alt="B[(n+1)*T_p] = B[n*T_p]"/>.  This extends to:</p>
<div class="math">
<p><img src="_images/math/feaedd13a5444527e22d3532712f4e23dbc59f03.png" alt="B[m*T_p] = B[n*T_p], \forall m,n &gt; 0"/></p>
</div><p>which implies that:</p>
<div class="math">
<p><img src="_images/math/171f87f18e3be14ff2d7162761ac2f0f92e887e3.png" alt="B[t] = B[t + k*T_p], \forall k \in \mathbb{N} &gt; 0"/></p>
</div><p>meaning that the amount of data in the buffer versus time is a
<em>periodic function</em>, therefore the buffer size does not grow between
periods, and the system has a <em>finite buffer</em>.</p>
<p>If we are only concerned with buffer growth, we do not need to
calculate <img class="math" src="_images/math/9d86170e7de539c0ff999de09621ee0c7b6c8ed0.png" alt="R"/>, and can instead infer buffer growth by comparing
the values of the buffer at any two period-offset times during the
steady-state operation of the system (<img class="math" src="_images/math/7bca1764693474a28844c96d8310bca28a0509b8.png" alt="t &gt;= T_p"/>).  This means
that the system buffer growth check can resolve to <img class="math" src="_images/math/22f50a751ef795d2b5dd655238463e698c18a4c9.png" alt="B[2*T_p] ==
B[T_p]"/>.  This comparison abides by the conditions above, with
<img class="math" src="_images/math/70040fec2de75cc96fc8cc94208dbfc28684cc85.png" alt="m=2"/> and <img class="math" src="_images/math/163a19eac5182aaabe8bd9cc931dfa15e75a71dc.png" alt="n=1"/>.</p>
</div>
</div>
<div class="section" id="comparison-with-nc-rtc">
<span id="nc-comparison"></span><h2>Comparison with NC/RTC<a class="headerlink" href="#comparison-with-nc-rtc" title="Permalink to this headline">¶</a></h2>
<p>To show how our analysis techniques compare to other available
methods, we developed our tools to allow us to analyze the input
system using Network Calculus/Real-Time Calculus techniques as well as
our own.  Using these capabilities, we can directly compare the
analysis results to each other, and then finally compare both results
to the measurements from the actual system.</p>
<p>Taking the results from our published work, where our methods
predicted a buffer size of 64000 bits / 8000 bytes, we show that
Network Calculus predicts a required buffer size of 3155000 bits.</p>
<div class="figure align-center" id="id5">
<a class="reference internal image-reference" href="_images/maren_namek_bw.png"><img alt="_images/maren_namek_bw.png" src="_images/maren_namek_bw.png" style="width: 400px; height: 400px;" /></a>
<p class="caption"><span class="caption-text">Bandwidth profile describing the system and application.</span></p>
</div>
<div class="figure align-center" id="id6">
<a class="reference internal image-reference" href="_images/maren_namek_data.png"><img alt="_images/maren_namek_data.png" src="_images/maren_namek_data.png" style="width: 400px; height: 400px;" /></a>
<p class="caption"><span class="caption-text">Analysis of the system with our tools.</span></p>
</div>
<div class="figure align-center" id="id7">
<a class="reference internal image-reference" href="_images/nc_namek_data.png"><img alt="_images/nc_namek_data.png" src="_images/nc_namek_data.png" style="width: 400px; height: 400px;" /></a>
<p class="caption"><span class="caption-text">Network-Calculus based analysis of the system.</span></p>
</div>
<p>The major drawback for Network Calculus that our work aims to solve is
the disconnect from the real system that stems from using an approach
based on time-window analysis.  Such an approach leads to dramatically
under-approximating the capacity of the network while simultaneously
over-approximating the utilization of the network, since a known drop
in network performance which is expected and handled by the
application cannot be accurately modeled.  In our case, the system is
using a system profile which can service data during the period from
<img class="math" src="_images/math/76ef67173b0843b70edb0503ab614cc3d716ddf2.png" alt="0\le t\le 7"/> seconds with a period of 10 seconds.  The
application is designed around this constraint and only produces data
during that interval.  Because our technique directly compares when
the application produces data to when the system can service the data,
we are able to derive more precise performance prediction metrics than
Network Calculus, which compares the 3 seconds of system downtime to
the 3 seconds of maximum application data production.</p>
<p>We developed software which produces data according to a supplied
input profile and configured the system&#8217;s network to provide the
bandwidth profile described in the system configuration profile.
Using this experimental infrastructure, we were able to measure the
transmitted traffic profile, the received traffic profile, the latency
experienced by the data, and the transmitter&#8217;s buffer requirements.
The results are displayed in the table below:</p>
<table border="1" class="docutils">
<colgroup>
<col width="32%" />
<col width="21%" />
<col width="47%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">&nbsp;</th>
<th class="head">Predicted</th>
<th class="head">Measured (<img class="math" src="_images/math/4b4dedc5cdec56161ae4dac2a0baf86f1c72b094.png" alt="\mu,\sigma"/>)</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Buffer Delay (s)</td>
<td>0.0625</td>
<td>(0.06003 , 0.00029)</td>
</tr>
<tr class="row-odd"><td>Time of Delay (s)</td>
<td>3.0</td>
<td>(2.90547 , 0.00025)</td>
</tr>
<tr class="row-even"><td>Buffer Size (bytes)</td>
<td>8000</td>
<td>(7722.59 , 36.94)</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="analysis-of-tdma-scheduling">
<span id="tdma-analysis"></span><h2>Analysis of TDMA Scheduling<a class="headerlink" href="#analysis-of-tdma-scheduling" title="Permalink to this headline">¶</a></h2>
<p>Medium channel access (MAC) protocols are used in networking systems
to govern the communication between computing nodes which share a
network communications medium.  They are designed to allow reliable
communication between the nodes, while maintaining certain goals, such
as minimizing network collisions, maximizing bandwidth, or maximizing
the number of nodes the network can handle.  Such protocols include
Time Division Multiple Access (TDMA), which tries to minimize the
number of packet collisions; Frequency Division Multiple Access
(FDMA), which tries to maximize the bandwidth available to each
transmitter; and Code Division Multiple Access (CDMA) which tries to
maximize the number of nodes that the network can handle.  We will not
discuss CDMA in the scope of this work.</p>
<p>In FDMA, each node of the network is assigned a different transmission
frequency from a prescribed frequency band allocated for system
communications.  Since each node transmits on its own frequency,
collisions between nodes transmitting simultaneously are reduced.
Communications paradigms of this type, i.e. shared medium with
collision-free simultaneous transmission between nodes, can be modeled
easily by our MAReN modeling paradigm described above, since the
network resource model for each node can be developed without taking
into account the transmissions of other nodes.</p>
<p>In TDMA, each node on the network is assigned one or more time-slots
per communications period in which only that node is allowed to
transmit.  By governing these timeslots and having each node agree
upon the slot allocation and communications period, the protocol
ensures that at a given time, only a single node will be transmitting
data, minimizing the number of collisions due to multiple simultaneous
transmitters.  In such a medium access protocol, transmissions of each
node affect other nodes&#8217; transmission capability.  Because these
transmissions are scheduled by TDMA, they can be explicitly integrated
into the system network resource model.</p>
<p>TDMA transmission scheduling has an impact on the timing
characteristics of the applications&#8217; network communications.  Because
applications&#8217; network data production is decoupled from their node&#8217;s
TDMA transmission time slot, buffering may be required when an
application on one node tries to send data on the network during the
transmission slot of a different node.  In this case, the data would
need to be buffered on the application&#8217;s node and would therefore
incur additional buffering delay.  If this TDMA schedule is not
integrated into the analysis of the network resources, the additional
buffer space required may exceed the buffer space allocation given to
the application or the buffering delay may exceed the application&#8217;s
acceptable latency.</p>
<p>So far, the description of the system provided network service profile
(<img class="math" src="_images/math/380e32ec071686ecc085988bde7ac1814b342625.png" alt="p[t]=y"/>), has been abstracted as simply the available
bandwidth as a function of time integrated to produce the amount of
data serviced as a function of time. We show how to model and analyze
the network&#8217;s lower-level TDMA MAC protocol using our network modeling
semantics.  We then derive general formulas for determining the affect
TDMA has on buffer size and delay predictions.</p>
<p>As an example TDMA system which benefits from our analysis techniques,
consider an application platform provided by a fractionated satellite
cluster.  A fractionated satellite cluster consists of many small
satellites that may each have different hardware, computing, and
communications capabilities.  These capabilities are provided to
distributed components of the satellite cluster&#8217;s applications.  Such
a system has the combined challenges of (1) being expensive to
develop, test, and deploy, (2) being very difficult to repair or
replace in the event of failure, and (3) having to support
mixed-criticality and possibly multiple levels of security
applications.  For this system, the network between these satellites
is a precious resource shared between each of the applications&#8217;
components in the cluster.  To ensure the stability of the network
resources, each satellite has a direct connection to every other
satellite and is assigned a slot in the TDMA schedule during which the
satellite may transmit.  Each TDMA slot has a sinusoidally
time-varying bandwidth profile which may differ from the other TDMA
slot bandwidth profiles.  The time-varying profile of the slot
bandwidth comes from the coupling between the radios&#8217; inverse-squared
bandwidth-as-a-function-of-distance and the satellites&#8217; sinusoidal
distance-as-a-function-of-orbital-position.</p>
<p>Such a system and applications necessitates design-time guarantees
about resource utilization and availability.  Applications which
utilize the satellite network need assurances that the network
resources they require during each part of the orbital period will be
satisfied.  To provide these assurances, we provide the application
developers and system integrators the ability to specify and analyze
the network profiles as (possibly periodic) functions of time.
Furthermore, the requirement for accurate predictions necessitates the
incorporation of the TDMA scheduling and bandwidth profiling into the
network modeling and analysis tools.</p>
<p>TDMA schedules can be described by their period, their number of
slots, and the bandwidth available to each slot as a function of time.
For simplicity of explanation, we assume that each node only gets a
single slot in the TDMA period and all slots have the same length, but
the results are valid for all static TDMA schedules.  Note that each
slot still has a bandwidth profile which varies as a function of time
and that each slots may have a different bandwidth profile.  In a
given TDMA period (<img class="math" src="_images/math/6d42c88506b8da39a2a23653aecbfb7c29728063.png" alt="T"/>), the node can transmit a certain number
of bits governed by its slot length (<img class="math" src="_images/math/cf9587087c31a9c170c37ca7b177cbba7dd214b8.png" alt="t_{slot}"/>) and the slot&#8217;s
available bandwidth (<img class="math" src="_images/math/b5aaef650b359f1ef3ce8bd77a565a360c1cd610.png" alt="bw_{slot}"/>).  During the rest of the TDMA
period, the node&#8217;s available bandwidth is <img class="math" src="_images/math/74c081db590f3d35421c1f6b9afd4cdda36ee210.png" alt="0"/>.  This scheduling
has the effect of amortizing the node&#8217;s slot bandwidth into an
effective bandwidth of <img class="math" src="_images/math/7a2a5b141cbf3fe40c9626c35cf419cd5206e4a2.png" alt="bw_{effective} = bw_{slot} *
\dfrac{t_{slot}}{T}"/>.  The addition of the TDMA scheduling can affect
the buffer and delay calculations, based on the slot&#8217;s bandwidth, the
number of slots, and the slot length.  The maximum additional delay is
<img class="math" src="_images/math/aa52ef22198842540e73e53c88f8e67cdcfefad8.png" alt="\Delta_{delay} = T - t_{slot}"/>, and the maximum additional
buffer space is <img class="math" src="_images/math/40f6366fdabeedf2fa9a799fb062c1797e6011f7.png" alt="\Delta_{buffer} = \Delta_{delay} *
bw_{effective}"/>.  These deviations are shown below.  Clearly,
<img class="math" src="_images/math/e2678b0d7673a4e642bca4131b013ff653c6da9d.png" alt="\Delta_{delay}"/> is bounded by <img class="math" src="_images/math/6d42c88506b8da39a2a23653aecbfb7c29728063.png" alt="T"/> and
<img class="math" src="_images/math/78014df4d22e583ce4060d725331e353dbda529d.png" alt="\Delta_{buffer}"/> is governed by <img class="math" src="_images/math/cf9587087c31a9c170c37ca7b177cbba7dd214b8.png" alt="t_{slot}"/>.  Therefore,
because <img class="math" src="_images/math/cf9587087c31a9c170c37ca7b177cbba7dd214b8.png" alt="t_{slot}"/> is dependent on <img class="math" src="_images/math/6d42c88506b8da39a2a23653aecbfb7c29728063.png" alt="T"/>, minimizing
<img class="math" src="_images/math/6d42c88506b8da39a2a23653aecbfb7c29728063.png" alt="T"/> minimizes both the maximum extra delay and maximum extra
buffer space.</p>
<table border="1" class="docutils">
<colgroup>
<col width="49%" />
<col width="51%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">In-Phase TDMA profile vs abstract</th>
<th class="head">Out-of-Phase TDMA Profile vs abstract</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><a class="first last reference internal image-reference" href="_images/tdma_phase0.png"><img alt="_images/tdma_phase0.png" src="_images/tdma_phase0.png" style="height: 200px;" /></a>
</td>
<td><a class="first last reference internal image-reference" href="_images/tdma_phase1.png"><img alt="_images/tdma_phase1.png" src="_images/tdma_phase1.png" style="height: 200px;" /></a>
</td>
</tr>
</tbody>
</table>
<p>Following from this analysis, we see that if: (1) the TDMA effective
bandwidth profile is provided as the abstract system network service
profile, and (2) the TDMA period is much smaller than the duration of
the shortest profile interval; then the system with explicit modeling
of the TDMA schedule has similar predicted application network
characteristics as the abstract system.  Additionally, the maximum
deviation formulas derived above provide a means for application
developers to analyze the their application on a TDMA system without
explicitly integrating the TDMA model into the system profile model.</p>
</div>
<div class="section" id="compositional-analysis">
<span id="id2"></span><h2>Compositional Analysis<a class="headerlink" href="#compositional-analysis" title="Permalink to this headline">¶</a></h2>
<p>Now that we have precise network performance analysis for aggregate
flows or singular flows on individual nodes of the network, we must
determine how best to compose these flows and nodes together to
analyze the overal system.  The aim of this work is to allow the flows
from each application to be analyzed separately from the other flows
in the network, so that application developers and system integrators
can derive meaningful perfomance predictions for specific
applications.</p>
<p>We have implemented min-plus calculus based compositional operations
for the network profiles which allow us to compose and decompose
systems based on functional components.  For network flows, this means
we can analyze flows individually to determine per-flow performance
metrics or we can aggregate flows together to determine aggregate
performance.</p>
<p>The composition is priority based, with each flow receiving a unique
priority.  This priority determines the oder in which the flows are
individually analyzed, with the system&#8217;s remaining capacity being
provided to the flow with the next highest priority.  This is similar
to the modular performance analysis provided by Real-Time Calculus.</p>
<p>The basis for this priority-based interaction is the QoS management
provided by many different types of networking infrastructure.
DiffServ&#8217;s DSCP provides one mechanism to implement this
priority-based transmission and routing.</p>
<p>We are finalizing the design and code for tests which utilize the DSCP
bit(s) setting on packet flows to show that such priority-based
analysis techniques are correct for these types of systems.</p>
</div>
<div class="section" id="delay-analysis">
<span id="id3"></span><h2>Delay Analysis<a class="headerlink" href="#delay-analysis" title="Permalink to this headline">¶</a></h2>
<p>When dealing with queueing systems (esp. networks) where precise
design-time guarantees are required, the delay in the links of the
network must be taken into account.</p>
<p>The delay is modeled as a continuous function of latency (seconds)
versus time.  In the profiles, the latency is specified discretely as
<img class="math" src="_images/math/91afa6a0c10f8e9475164168f94fe6080b3bc3f9.png" alt="(time, latency)"/> pairs, and is interpolated linearly between
successive pairs.</p>
<p>Using these latency semantics, the delay convolution of a profile
becomes</p>
<div class="math">
<p><img src="_images/math/58781499305d2973dc0695f586fc8daa50ad2fe3.png" alt="r[t + \delta[t]] = l[t]"/></p>
</div><p>Where</p>
<ul class="simple">
<li><img class="math" src="_images/math/c52328274518603a2cc478a4db8925ffa035faed.png" alt="l[t]"/> is the <em>link</em> profile describing the data as a function
of time as it enters the link</li>
<li><img class="math" src="_images/math/2a0a2f67e07caa3e17e5f8f645b78f5cad3812dd.png" alt="\delta[t]"/> is the <em>delay</em> profile describing the latency as a
function of time on the link</li>
<li><img class="math" src="_images/math/8d85052c33844b2074fa63b28dcb671b60af6411.png" alt="r[t]"/> is the <em>received</em> profile describing the data as a
function of time as it is received at the end of the link</li>
</ul>
<p>When analyzing delay in a periodic system, it is important to
determine the effects of delay on the system&#8217;s periodicity.  We know
that the period of the periodic profiles is defined by the time
difference between the start of the profile and the end of the
profile.  Therefore, we can show that if the time difference between
the <strong>start time</strong> of the <em>received</em> profile and the <strong>end time</strong> of
the <em>received</em> profile is the same as the <strong>period</strong> of the <em>link</em>
profile, the periodicity of the profile is unchanged.</p>
<ul class="simple">
<li><img class="math" src="_images/math/d3a93ce5fdd86a1a6cea538e4b3ad7616156ff25.png" alt="T_p"/> is the period of the <em>link</em> profile</li>
<li><img class="math" src="_images/math/bb9f50d66397f6337f4cfddb0ca20a1977e482ce.png" alt="r[t + \delta[t]]"/> is the beginning of the <em>received</em> profile</li>
<li><img class="math" src="_images/math/c80e1df5ca2c0f162a61382b667eecc1026dc37f.png" alt="r[(t + T_p) + \delta[(t + T_p)]]"/> is the end of the
<em>received</em> profile</li>
</ul>
<p>We determine the condition for which <img class="math" src="_images/math/b1021500b5fe6128b7c4c8eb175cb1585710e999.png" alt="(t_{end}) - (t_{start}) =
T_p"/>:</p>
<div class="math">
<p><img src="_images/math/46245c7be404e773c109d1748baac82a5d546fcd.png" alt="(T_p + t + \delta[T_p + t]) - (t + \delta[t]) &amp;= T_p \\
T_p + \delta[T_p + t] - \delta[t] &amp;= T_p \\
\delta[T_p + t] - \delta[t] &amp;= 0\\
\delta[T_p + t] &amp;= \delta[t]"/></p>
</div><p>Which is just confirms that the periodicity of the delayed profile is
unchanged <em>iff</em> the latency profile is <strong>periodic</strong>, i.e.</p>
<div class="math">
<p><img src="_images/math/dc90d07f427d8cceca6257bcd610427067e32b93.png" alt="\delta[t] = \delta[t + k*T_p], \forall k\in\mathbb{N} &gt; 0"/></p>
</div></div>
<div class="section" id="routing-analysis">
<span id="id4"></span><h2>Routing Analysis<a class="headerlink" href="#routing-analysis" title="Permalink to this headline">¶</a></h2>
<p>By incorporating both the latency analysis with the compositional
operations we developed, we can perform system-level analysis of flows
which are routed by nodes of the system.  In this paradigm, nodes can
transmit/receive their own data, i.e. they can host applications which
act as data sources or sinks, as well as act as routers for flows from
and to other nodes.  To make such a system amenable to analysis we
must ensure that we know the routes the flows will take at design
time, i.e. the routes in the network are static and known or
calculable.  Furthermore, we must, for the sake of flow composition as
decribed above, ensure that each flow has a priority that is unique
within the network which governs how the transmitting and routing
nodes handle the flow&#8217;s data.</p>
<p>We have extended our network analysis tool to support such system
analysis by taking as input:</p>
<ul class="simple">
<li>the sender flows and receiver functions in the network</li>
<li>the provided service of each node in the network</li>
<li>the network configuration specifying the nodes in the network and
the routes in the network</li>
</ul>
<p>where a flow is defined by:</p>
<ul class="simple">
<li>Node ID of the profile</li>
<li>Kind of the flow</li>
<li>Period of the flow</li>
<li>Flow type of the profile</li>
<li>Priority of the flow</li>
<li>flow properties vs time profile</li>
</ul>
<p>and a route is specified as a list of node IDs starting with the
source node ID and ending with the destination node ID.  Any flows
which have the respective source and destination IDs must travel along
the path specified by the respective route.</p>
<p>We can then run the following algorithm to iteratively analyze the
flows and the system</p>
<div class="highlight-C#"><div class="highlight"><pre><span class="n">analyze</span><span class="p">(</span> <span class="n">profiles</span> <span class="p">)</span>
<span class="p">{</span>
  <span class="n">profiles</span> <span class="p">=</span> <span class="n">sorted</span><span class="p">(</span><span class="n">profiles</span><span class="p">,</span> <span class="n">priority</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">required</span> <span class="k">in</span> <span class="n">profiles</span>
  <span class="p">{</span>
    <span class="n">transmitted_nodes</span> <span class="p">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">receiver</span> <span class="k">in</span> <span class="n">required</span><span class="p">.</span><span class="n">receivers</span><span class="p">()</span>
    <span class="p">{</span>
      <span class="n">route</span> <span class="p">=</span> <span class="n">required</span><span class="p">.</span><span class="n">route</span><span class="p">()</span>
      <span class="k">for</span> <span class="n">node</span> <span class="k">in</span> <span class="n">route</span>
      <span class="p">{</span>
        <span class="k">if</span> <span class="n">node</span> <span class="k">in</span> <span class="n">transmitted_nodes</span> <span class="n">and</span> <span class="n">multicast</span> <span class="p">==</span> <span class="k">true</span>
        <span class="p">{</span>
          <span class="k">continue</span>
        <span class="p">}</span>
        <span class="n">provided</span> <span class="p">=</span> <span class="n">node</span><span class="p">.</span><span class="n">provided</span>
<span class="na">        [output, remaining, received]</span> <span class="p">=</span> <span class="n">convolve</span><span class="p">(</span><span class="n">required</span><span class="p">,</span> <span class="n">provided</span><span class="p">)</span>
        <span class="n">node</span><span class="p">.</span><span class="n">provided</span> <span class="p">=</span> <span class="n">remaining</span>
        <span class="n">required</span> <span class="p">=</span> <span class="n">received</span>
        <span class="n">transmitted_nodes</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
      <span class="p">}</span>
<span class="na">      [recv_output, recv_remaining, ]</span> <span class="p">=</span> <span class="n">convolve</span><span class="p">(</span><span class="n">required</span><span class="p">,</span> <span class="n">receiver</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In this algorithm, the remaining capacity of the node is provided to
each profile with a lower priority iteratively.  Because of this
iterative recalculation of node provided profiles based on routed
profiles, we directly take into account the effect of multiple
independent flows traversing the same router; the highest priority
flow receives as much bandwidth as the router can give it, the next
highest priority flow receives the remaining bandwidth, and so on.</p>
<p>We take care of matching all senders to their respective receivers,
and ensure that if the system supports multicast, a no retransmissions
occur; only nodes which must route the flow to a new part of the
network retransmit the data.  However, if the system does not support
multicast, then the sender must issue a separate transmission, further
consuming network resources.  In this way, lower-level transport
capabilities can be at least partially accounted for by our analysis.</p>
<p>We have implmented these functions for statically routed network
analysis into our tool, which automatically parses the flow profiles,
the network configuration and uses the algorithm and the implemented
mathematics to iteratively analyze the network.  Analytical results
for example systems will be provided when the experimental results can
be used as a comparison.</p>
<p>We are finishing the design and development of code which will allow
us to run experiments to validate our routing analysis results.  They
will be complete in the next two weeks.</p>
</div>
</div>


          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="run-time.html" class="btn btn-neutral float-right" title="Run Time Results" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="results.html" class="btn btn-neutral" title="Precise Network Performance Prediction : Results" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015, finger563.
    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'0.2.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
  
 
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-61341323-1', 'auto');
  ga('send', 'pageview');
</script>


</body>
</html>