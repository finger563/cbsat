.. _math:

Math
====

This page describes the mathematical formalization
behind the network analysis techniques used by this
tool.  These techniques are based on Network Calculus
and have been published in these papers.

.. _network_calc_background:

Network Calculus Background
---------------------------

Network Calculus, on the other hand, focuses on abstracting the network traffic and the computing nodes as arrival curves and traffic shapers. The arrival curves and service curves model the amount of data generated or serviced in a given window of time and are bounded by maximum and minimum arrival and service curves.  These bounds provide the requisite information needed to make design-time guarantees about *worst-case* application performance on the network, given that both the application traffic profile and the system's network performance are deterministic. These deterministic constraints can be relaxed so that the arrival and service curves can be probabilistic, causing the bounds on the performance to be probabilistic as well.  Because Network Calculus deals with either deterministic worst-case application performance on a static network or stochastic application performance on a dynamic network, system designers and application designers under-utilize the network resources of systems which require strict design-time guarantees about application performance.  

.. _network_math_formalism:

Formalism for Better Precision Network Analysis
-----------------------------------------------

To model the network capability of the system and the application traffic patterns, we have developed a network modeling paradigm similar to Network Calculus' traffic arrival curves and traffic shaper service curves.  

Similarly to Network Calculus' arrival curves and service curves, our network profiles model how the network performance or application traffic generation changes with respect to time.  Whereas Network Calculus' modeling transforms application data profiles and network service profiles into min and max curves for data received vs. size of time-window, our models take a simpler, deterministic approach which models exactly the data generated by the application and the data which could be sent through the network, allowing our performance metrics to be more precise.  Specifically, the bandwidth that the network provides on a given communication link is specified as a time series of scalar bandwidth values. Here, bandwidth is defined as data rate, i.e. bits per second, over some averaging interval.  This bandwidth profile can then be time-integrated to determine the maximum amount of data throughput the network link could provide over a given time.  The bandwidth profile for the application traffic similarly can be time-integrated to determine the amount of data that the application attempts to send on the network link as a function of time.

Having time-integrated the bandwidth profiles to obtain data vs. time profiles that the application requires and that the system provides, we can use convolution (:math:`\otimes`) on these two profiles to obtain the transmitted link data profile as a function of discrete time. The convolution we define on these profiles borrows concepts from the min-plus calculus used in Network Calculus, but does not use a sliding-window and instead takes the transformed minimum of the profiles. For a given application data generation profile, :math:`r[t]`, and a given system link capacity profile :math:`p[t]`, where :math:`t\in\mathbb{N}`, the link transmitted data profile :math:`l[t]` is given by the convolution Equation~\ref{eq:convolution}. The difference :math:`(p[t-1] - l[t-1])` represents the difference between the amount of data that has been transmitted on the link :math:`(l[t-1])` and the data that the link could have transmitted at full utilization :math:`(p[t-1])`. As demonstrated by the convolution equation, :math:`\forall t : l[t] \le r[t]`, which is the relation that, without lower-layer reliable transport, the link cannot transmit more application data for the application than the application requests as there will be packetization and communication header overhead as well. 

.. math::
   y=l[t] &= (r \otimes p)[t] \\
   &= min( r[t] , p[t] - (p[t-1] - l[t-1]) )

   &\text{buffer}= sup\{r[t] - l[t] : t \in \mathbb{N}\}\\
   &\text{delay} = sup\{l^{-1}[y]-r^{-1}[y] : y \in \mathbb{N}\}

.. figure:: /images/math/convolution.png
   :align: center

So far, the description of the system provided network service profile (:math:`p[t]=y`), has been abstracted as simply the available bandwidth as a function of time integrated to produce the amount of data serviced as a function of time.  In order to more precisely model the system, a network medium channel access protocol must be integrated into the abstract system provided profile.  TDMA is such a protocol which assigns to each node one or more time slots in a repeating period during which only the selected node is allowed to transmit.  We show how to model such a protocol and extend the abstract system network profile to include the model of the TDMA channel access protocol.  

As an example TDMA system which benefits from our analysis techniques, consider an application platform provided by a fractionated satellite cluster.  A fractionated satellite cluster consists of many small satellites that may each have different hardware, computing, and communications capabilities.  These capabilities are provided to distributed components of the satellite cluster's applications.  Such a system has the combined challenges of (1) being expensive to develop, test, and deploy, (2) being very difficult to repair or replace in the event of failure, and (3) having to support mixed-criticality and possibly multiple levels of security applications.  For this system, the network between these satellites is a precious resource shared between each of the applications' components in the cluster.  To ensure the stability of the network resources, each satellite has a direct connection to every other satellite and is assigned a slot in the TDMA schedule during which the satellite may transmit.  Each TDMA slot has a sinusoidally time-varying bandwidth profile which may differ from the other TDMA slot bandwidth profiles.  The time-varying profile of the slot bandwidth comes from the coupling between the radios' inverse-squared bandwidth-as-a-function-of-distance and the satellites' sinusoidal distance-as-a-function-of-orbital-position.

Such a system and applications necessitates design-time guarantees about resource utilization and availability.  Applications which utilize the satellite network need assurances that the network resources they require during each part of the orbital period will be satisfied.  To provide these assurances, we provide the application developers and system integrators the ability to specify and analyze the network profiles as (possibly periodic) functions of time.  Furthermore, the requirement for accurate predictions necessitates the incorporation of the TDMA scheduling and bandwidth profiling into the network modeling and analysis tools.    

TDMA schedules can be described by their period, their number of slots, and the bandwidth available to each slot as a function of time.  For simplicity of explanation, we assume that each node only gets a single slot in the TDMA period and all slots have the same length, but the results are valid for all static TDMA schedules.  Note that each slot still has a bandwidth profile which varies as a function of time and that each slots may have a different bandwidth profile.  In a given TDMA period (:math:`T`), the node can transmit a certain number of bits governed by its slot length (:math:`t_{slot}`) and the slot's available bandwidth (:math:`bw_{slot}`).  During the rest of the TDMA period, the node's available bandwidth is :math:`0`.  This scheduling has the effect of amortizing the node's slot bandwidth into an effective bandwidth of :math:`bw_{effective} = bw_{slot} * \dfrac{t_{slot}}{T}`.  The addition of the TDMA scheduling can affect the buffer and delay calculations, based on the slot's bandwidth, the number of slots, and the slot length.  The maximum additional delay is :math:`\Delta_{delay} = T - t_{slot}`, and the maximum additional buffer space is :math:`\Delta_{buffer} = \Delta_{delay} * bw_{effective}`.  These deviations are shown in Figure~\ref{fig:deviation}.  Clearly, :math:`\Delta_{delay}` is bounded by :math:`T` and :math:`\Delta_{buffer}` is governed by :math:`t_{slot}`.  Therefore, because :math:`t_{slot}` is dependent on :math:`T`, minimizing :math:`T` minimizes both the maximum extra delay and maximum extra buffer space.
